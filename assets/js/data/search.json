[ { "title": "leetCode Day50", "url": "/posts/leetCode-Day50/", "categories": "leetCode", "tags": "Tang", "date": "2022-12-26 00:00:00 +0800", "snippet": "Find the Duplicate Number題目:有一個數字陣列,有n + 1的數字,數字的值為1~n,求陣列中重複的數字解法:建立一個陣列,用數字為key,值為bool,數字出現過設定為true,如果數字為true,代表重複出現 codefunc findDuplicate(nums []int) int { exist := make([]bool, len(nums)) for _, value := range nums { if exist[value] { return value } exist[value] = true } return 0}" }, { "title": "leetCode Day49", "url": "/posts/leetCode-Day49/", "categories": "leetCode", "tags": "Tang", "date": "2022-12-24 00:00:00 +0800", "snippet": "Remove Nth Node From End of List題目:有一個列表,刪除從後面數來第n個節點解法:因為我們要找出後面數來第n個,所以我們可以用初始點和出點後往後n個當作依據,同時往後,執到後面那個跑到最後一個,前面的就會是需要刪除節點的前一個節點,把前一個節點的下一個節點,設定為下兩個節點,就可以刪除該節點 code/** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */func removeNthFromEnd(head *ListNode, n int) *ListNode { left := head right := head for i := 0; i &amp;lt; n; i++ { right = right.Next } if right == nil { return left.Next } for right.Next != nil { right = right.Next left = left.Next } left.Next = left.Next.Next return head}" }, { "title": "leetCode Day48", "url": "/posts/leetCode-Day48/", "categories": "leetCode", "tags": "Tang", "date": "2022-12-23 00:00:00 +0800", "snippet": "Pacific Atlantic Water Flow題目:有一個數字矩陣代表了水的高度,上方和左方為太平洋,右方和下方為大西洋,水會往低處流,求哪幾個節點同時流往太平洋和大西洋解法:如果使用每個節點往四周跑dfs的話,有很多點需要重複執行,導致timeout,所以定義兩個布林矩陣,為能到達太平洋或大西洋,從邊界開始往四周跑,最後看每個點是否通過太平洋和大西洋 codefunc pacificAtlantic(heights [][]int) [][]int { var result [][]int var p [][]bool var a [][]bool m := len(heights) n := len(heights[0]) for i := 0; i &amp;lt; m; i++ { p = append(p, make([]bool, n)) a = append(a, make([]bool, n)) } for i := 0; i &amp;lt; n; i++ { dfs(heights, 0, i, 0, &amp;amp;p) dfs(heights, m - 1, i, 0, &amp;amp;a) } for i := 0; i &amp;lt; m; i++ { dfs(heights, i, 0, 0, &amp;amp;p) dfs(heights, i, n - 1, 0, &amp;amp;a) } for i := 0; i &amp;lt; m; i++ { for j := 0; j &amp;lt; n; j++ { if p[i][j] &amp;amp;&amp;amp; a[i][j] { result = append(result, []int{i, j}) } } } return result}func dfs(heights [][]int, x int, y int, val int, pass *[][]bool) { if x &amp;lt; 0 || y &amp;lt; 0 || x &amp;gt;= len(heights) || y &amp;gt;= len(heights[0]) { return } if (*pass)[x][y] || heights[x][y] &amp;lt; val { return } (*pass)[x][y] = true dfs(heights, x + 1, y, heights[x][y], pass) dfs(heights, x, y + 1, heights[x][y], pass) dfs(heights, x - 1, y, heights[x][y], pass) dfs(heights, x, y - 1, heights[x][y], pass)}" }, { "title": "leetCode Day47", "url": "/posts/leetCode-Day47/", "categories": "leetCode", "tags": "Tang", "date": "2022-12-20 00:00:00 +0800", "snippet": "Maximum Product Subarray題目:有一個數字陣列,求子陣列中,乘積最大解法:使用動態規劃,定義乘積最大和最小,如果值為正,乘積最大為max(dpMax[i-1]*nums[i],nums[i]),乘積最小為min(dpMin[i-1]*nums[i],nums[i]),如果值為負數,乘積最大為max(dpMin[i-1]*nums[i],nums[i]),乘積最小為min(dpMax[i-1]*nums[i],nums[i]) codefunc maxProduct(nums []int) int { dpMax := make([]int, len(nums)) dpMin := make([]int, len(nums)) dpMax[0] = nums[0] dpMin[0] = nums[0] maximum := nums[0] for i := 1; i &amp;lt; len(nums); i++ { if nums[i] &amp;gt; 0 { dpMax[i] = max(dpMax[i - 1] * nums[i], nums[i]) dpMin[i] = min(dpMin[i - 1] * nums[i], nums[i]) } else { dpMax[i] = max(dpMin[i - 1] * nums[i], nums[i]) dpMin[i] = min(dpMax[i - 1] * nums[i], nums[i]) } if maximum &amp;lt; dpMax[i] { maximum = dpMax[i] } } return maximum}func max(a, b int) int { if a &amp;gt; b { return a } return b}func min(a, b int) int { if a &amp;gt; b { return b } return a}Design Add and Search Words Data Structure題目:製作一個可以新增字串,並可以查詢字串存不存在的資料結構,如果查詢字串中有.代表可以是任意字母解法:先算出字串長度,新增進該字串長度的矩陣中,查詢時如果,該字串長度沒有值,返回false,如果有就查看字串是否一致 codetype WordDictionary struct { Data [][]string}func Constructor() WordDictionary { var data [][]string for i := 0; i &amp;lt;= 25; i++ { data = append(data, make([]string, 0)) } return WordDictionary{Data: data}}func (this *WordDictionary) AddWord(word string) { strlen := len(word) this.Data[strlen] = append(this.Data[strlen], word) fmt.Println(len(this.Data[strlen]))}func (this *WordDictionary) Search(word string) bool { strlen := len(word) if len(this.Data[strlen]) == 0 { return false } for _, value := range this.Data[strlen] { flag := true for i := 0; i &amp;lt; strlen; i++ { if word[i] == &#39;.&#39; { continue } if word[i] != value[i] { flag = false break } } if flag { return true } } return false}/** * Your WordDictionary object will be instantiated and called as such: * obj := Constructor(); * obj.AddWord(word); * param_2 := obj.Search(word); */" }, { "title": "leetCode Day46", "url": "/posts/leetCode-Day46/", "categories": "leetCode", "tags": "Tang", "date": "2022-12-19 00:00:00 +0800", "snippet": "Next Permutation題目:有一個數字陣列,找出下一個比較大的最小數,如果都沒有的話,返回最小數解法:從後往前看,如果為順序遞增的話,返回排序陣列,如果中間有一數較小,找出該數位置,再由後往前找出最小大於該數的位置,由於後往前一定為遞增,所以從後往前遇到的第一個比較大的數一定是最小的,兩個位置交換,在將i後面的數字排序 codefunc nextPermutation(nums []int) { i := len(nums) - 1 for i &amp;gt;= 1 &amp;amp;&amp;amp; nums[i] &amp;lt;= nums[i - 1] { i-- } if i == 0 { sort.Ints(nums) return } i-- j := len(nums) - 1 for j &amp;gt; i &amp;amp;&amp;amp; nums[i] &amp;gt;= nums[j] { j-- } nums[i], nums[j] = nums[j], nums[i] sort.Ints(nums[i + 1:]) return}Valid Sudoku題目:9*9數獨,判斷行列不能重複,3*3小數獨也不能重複,返回true,有重複返回false解法:如果行列和小數獨都沒有重複,此數獨一定成立 codefunc isValidSudoku(board [][]byte) bool { for i := 0; i &amp;lt; 9; i++ { rowCheck, colCheck, boxCheck := make([]bool, 9), make([]bool, 9), make([]bool, 9) for j := 0; j &amp;lt; 9; j++ { if board[i][j] != &#39;.&#39; { idx := board[i][j] - &#39;1&#39; if rowCheck[idx] { return false } rowCheck[idx] = true } if board[j][i] != &#39;.&#39; { idx := board[j][i] - &#39;1&#39; if colCheck[idx] { return false } colCheck[idx] = true } x, y := i / 3 * 3 + j / 3, i % 3 * 3 + j % 3 if board[x][y] != &#39;.&#39; { idx := board[x][y] - &#39;1&#39; if boxCheck[idx] { return false } boxCheck[idx] = true } } } return true}Group Anagrams題目:有一個字串陣列,把相似的字串組在一起,返回字串矩陣解法:將字串排序當作矩陣的key,把key相同的字串組合在同一個key中 codefunc groupAnagrams(strs []string) [][]string { var result [][]string solution := make(map[string][]string) for _, str := range strs { tmp := []byte(str) sort.Slice(tmp, func(i, j int) bool { return tmp[i] &amp;gt; tmp[j] }) key := string(tmp) solution[key] = append(solution[key], str) } for _, value := range solution { result = append(result, value) } return result}" }, { "title": "leetCode Day45", "url": "/posts/leetCode-Day45/", "categories": "leetCode", "tags": "Tang", "date": "2022-12-18 00:00:00 +0800", "snippet": "House Robber題目:一個數字陣列,值代表多少金額,有個小偷偷錢,如果偷相鄰的兩個會觸發警報,求小偷最多能偷多少錢解法:當前最大為前一個或是當前值+前第二個誰大,返回陣列最後的值,為最大值 codefunc rob(nums []int) int { if len(nums) == 1 { return nums[0] } dp := make([]int, len(nums)) dp[0] = nums[0] dp[1] = max(dp[0], nums[1]) for i := 2; i &amp;lt; len(nums); i++ { dp[i] = max(dp[i - 1], nums[i] + dp[i - 2]) } return dp[len(nums) - 1]}func max(a int, b int) int { if a &amp;gt; b{ return a } return b}Gas Station題目:有一個環形加油站,有每個站的加油數量和到下一個站所需的油量,如果能走完一圈返回從哪個點開始走,如果都不能返回-1解法:當前總和小於0的話,左邊總和為上個左邊總和+當前總和,當前總和為0,idx為當前+1,最後如果左邊總和+總和小於0,返回-1,大於等於0,返回idx codefunc canCompleteCircuit(gas []int, cost []int) int { var sum int var total int var idx int for i := 0; i &amp;lt; len(gas); i++ { sum += gas[i] - cost[i] if sum &amp;lt; 0 { idx = i + 1 total += sum sum = 0 } } if total + sum &amp;gt;= 0 { return idx } return -1}" }, { "title": "leetCode Day44", "url": "/posts/leetCode-Day44/", "categories": "leetCode", "tags": "Tang", "date": "2022-12-16 00:00:00 +0800", "snippet": "Daily Temperatures題目:有一個數字陣列,代表了每天的溫度,返回隔k天之後氣溫比較高該天高的陣列,如果沒有比較高的溫度,天數為0解法:用stack把之前的idx存起來,在跟現在的比大小,就可以找出k天 codefunc dailyTemperatures(temperatures []int) []int { ans := make([]int, len(temperatures)) stack := make([]int, len(temperatures)) top := -1 for i := 0; i &amp;lt; len(temperatures); i++ { for top &amp;gt; -1 &amp;amp;&amp;amp; temperatures[i] &amp;gt; temperatures[stack[top]] { idx := stack[top] ans[idx] = i - idx top-- } top++ stack[top] = i } return ans}" }, { "title": "leetCode Day43", "url": "/posts/leetCode-Day43/", "categories": "leetCode", "tags": "Tang", "date": "2022-12-15 00:00:00 +0800", "snippet": "LRU Cache題目:有一個暫存只有capacity個容量,如果資料超過容量,會把最早使用過的資料刪除解法:一個存容量一個存資料,如果容量不夠還需要存入,把資料最前面的刪除,再存入,因為取得資料也算是使用,所以取得如果有找到,需要把資料放到最後面 codetype Node struct { Key int Val int Prev *Node Next *Node}type LRUCache struct { Cap int Data map[int]*Node Head *Node Tail *Node}func Constructor(capacity int) LRUCache { return LRUCache{capacity, make(map[int]*Node), nil, nil}}func (this *LRUCache) Get(key int) int { node, ok := this.Data[key] if ok { this.Remove(node) this.Add(node) return node.Val } return -1}func (this *LRUCache) Put(key int, value int) { node, ok := this.Data[key] if ok { this.Remove(node) this.Add(node) node.Val = value } else { node = &amp;amp;Node{Key: key, Val: value} this.Data[key] = node this.Add(node) } if len(this.Data) &amp;gt; this.Cap { delete(this.Data, this.Head.Key) this.Remove(this.Head) }}func (this *LRUCache) Add(node *Node) { node.Next = nil node.Prev = this.Tail if this.Tail != nil { this.Tail.Next = node } this.Tail = node if this.Head == nil { this.Head = node }}func (this *LRUCache) Remove(node *Node) { if node == this.Head { this.Head = node.Next } else { node.Prev.Next = node.Next } if node == this.Tail { this.Tail = node.Prev } else { node.Next.Prev = node.Prev }}/** * Your LRUCache object will be instantiated and called as such: * obj := Constructor(capacity); * param_1 := obj.Get(key); * obj.Put(key,value); */Kth Smallest Element in a BST題目:在二分搜尋樹中找出第K個小個數解法:因為樹為二分收尋樹,所以inorder就會為樹的順序排列遍歷,所以我們往最走邊找出最小的值,再往右往上找出,第K個最小值 code/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */func kthSmallest(root *TreeNode, k int) int { var stack []*TreeNode for true { for root != nil { stack = append(stack, root) root = root.Left } root = stack[len(stack) - 1] stack = stack[:len(stack) - 1] k-- if k == 0 { return root.Val } root = root.Right } return 0}" }, { "title": "leetCode Day42", "url": "/posts/leetCode-Day42/", "categories": "leetCode", "tags": "Tang", "date": "2022-12-14 00:00:00 +0800", "snippet": "Minimum Height Trees題目:n為0~n-1的數字,edges為兩個數字的相連關西,此關西能組成一個樹,求哪個數字為根的話有最小的深度解法:因圖型一定為樹,所以找出此樹最外層的點,最外層的點為只有一個相鄰的數字,將最外層的點剝離後,判斷剩下的數字是否只剩下一個或兩個,如果是的話,返回答案,如果不是的話,將繼續把最外層的數字剝離 codefunc findMinHeightTrees(n int, edges [][]int) []int { if n == 1 { return []int{0} } var next [][]int var queue []int dagree := make([]int, n) for i := 0; i &amp;lt; n; i++ { next = append(next, make([]int, 0)) } for _, edge := range edges { a := edge[0] b := edge[1] dagree[a]++ dagree[b]++ next[a] = append(next[a], b) next[b] = append(next[b], a) } for key, value := range dagree { if value == 1 { queue = append(queue, key) } } for n &amp;gt; 2 { size := len(queue) n -= size for size &amp;gt; 0 { cur := queue[0] queue = queue[1:] for _, value := range next[cur] { dagree[value]-- if dagree[value] == 1 { queue = append(queue, value) } } size-- } } return queue}Task Scheduler題目:有一個字母陣列,每個字母代表一個任務,相同的字母代表相同的任務,相同任務執行之間需要n個間隔,每個時間只能執行一個任務或是暫停,求最短完成任務需要幾個時間解法:將每個字母出現次數找出來,把出現頻率由高往低存入queue中,如果queue中有資料持續執行,使用優先隊列,將n的數從queue中取出,並減1,如果大於1,再塞回queue中 codefunc leastInterval(tasks []byte, n int) int { if n == 0 { return len(tasks) } var result int n++ count := make(map[byte]int, len(tasks)) for _, value := range tasks { count[value]++ } var pq []int for _, value := range count { pq = append(pq, value) } sort.Slice(pq, func(i, j int) bool { return pq[i] &amp;gt; pq[j] }) for len(pq) &amp;gt; 0 { k := min(len(pq), n) tmp := make([]int, 0) for i:=0; i &amp;lt; k; i++ { cur := pq[0] pq = pq[1:] cur-- if cur &amp;gt; 0 { tmp = append(tmp, cur) } } for _, value := range tmp { pq = append(pq, value) } sort.Slice(pq, func(i, j int) bool { return pq[i] &amp;gt; pq[j] }) if len(tmp) == 0 { result += k } else { result += n } } return result}func min (a, b int) int { if a &amp;gt; b { return b } return a}" }, { "title": "leetCode Day41", "url": "/posts/leetCode-Day41/", "categories": "leetCode", "tags": "Tang", "date": "2022-12-13 00:00:00 +0800", "snippet": "Find All Anagrams in a String題目:有兩個字串,s和p,找出s字串中和p字串相似的子字串,並返回子字串開始的idx陣列解法:先找出p字串中字母的出現次數為P,再將s陣列從頭掃過一次,P將字母--,如果該字母為0的話將,idx刪除,如果i大於等於p的長度,需把前面的字母加回來,如果P長度為0的話,表示為相似字串,將idx-p長度+1存入結果中 codefunc findAnagrams(s string, p string) []int { var result []int P := make(map[byte]int) if len(p) &amp;gt; len(s) { return result } for i := 0; i &amp;lt; len(p); i++ { P[p[i]]++ } for i := 0; i &amp;lt; len(s); i++ { P[s[i]]-- if P[s[i]] == 0 { delete(P, s[i]) } if i &amp;gt;= len(p) { P[s[i - len(p)]]++ if P[s[i - len(p)]] == 0 { delete(P, s[i - len(p)]) } } if len(P) == 0 { result = append(result, i - len(p) + 1) } } return result}" }, { "title": "leetCode Day40", "url": "/posts/leetCode-Day40/", "categories": "leetCode", "tags": "Tang", "date": "2022-12-12 00:00:00 +0800", "snippet": "Letter Combinations of a Phone Number題目:給一串數字,求電話上面的字母的組合解法:先將數字代表的字串陣列定義出來,然後將每個數字帶入找出所有字串的組合 codevar M = map[byte]string { &#39;2&#39;: &quot;abc&quot;, &#39;3&#39;: &quot;def&quot;, &#39;4&#39;: &quot;ghi&quot;, &#39;5&#39;: &quot;jkl&quot;, &#39;6&#39;: &quot;mno&quot;, &#39;7&#39;: &quot;pqrs&quot;, &#39;8&#39;: &quot;tuv&quot;, &#39;9&#39;: &quot;wxyz&quot;,}func letterCombinations(digits string) []string { var result []string if len(digits) == 0 { return result } helper(digits, 0, &quot;&quot;, &amp;amp;result) return result}func helper(digits string, x int, s string, result *[]string) { if x == len(digits) { *result = append(*result, s) return } for _, value := range M[digits[x]] { helper(digits, x + 1, s + string(value), result) } return}Word Search題目:有一個字串矩陣,每個值代表一個字母,有一個字串,如果矩陣內相鄰的字母能組合出字串,返回true,另外矩陣內每個值只能使用一次解法:先定義一個矩陣,存放是否使用過,然後找出矩陣內字母和字串相同文字,再找相鄰的四個字母是否為字串的下一個字母,另外需判斷矩陣的字母是否之前有被使用過 codefunc exist(board [][]byte, word string) bool { var visited [][]bool var tmp []bool m := len(board) n := len(board[0]) for i := 0; i &amp;lt; n; i++ { tmp = append(tmp, false) } for i := 0; i &amp;lt; m; i++ { copyTmp := make([]bool, len(tmp)) copy(copyTmp, tmp) visited = append(visited, copyTmp) } for i := 0; i &amp;lt; m; i++ { for j := 0; j &amp;lt; n; j++ { if dfs(board, word, 0, i, j, m, n, visited) { return true } } } return false}func dfs(board [][]byte, word string, cur int, x int, y int, m int, n int, visited [][]bool) bool { if len(word) == cur { return true } if x &amp;lt; 0 || y &amp;lt; 0 || x &amp;gt;= m || y == n || board[x][y] != word[cur] || visited[x][y] { return false } visited[x][y] = true if dfs(board, word, cur + 1, x - 1, y, m, n, visited) || dfs(board, word, cur + 1, x + 1, y, m, n, visited) || dfs(board, word, cur + 1, x, y - 1, m, n, visited) || dfs(board, word, cur + 1, x, y + 1, m, n, visited) { return true } visited[x][y] = false return false }" }, { "title": "leetCode Day39", "url": "/posts/leetCode-Day39/", "categories": "leetCode", "tags": "Tang", "date": "2022-12-10 00:00:00 +0800", "snippet": "Container With Most Water題目:有一組數字陣列,值代表高度,index差距代表寬度,求能載入最大水量的面積是多少解法:預設頭尾為最大的面積,頭為i尾為j,如果i的高度大於j的高度,j--,反之i++,即可求得最大面積 codefunc maxArea(height []int) int { var result int i, j := 0, len(height) - 1 for i &amp;lt; j { result = max(result, min(height[i], height[j]) * (j - i)) if height[i] &amp;gt; height[j] { j-- } else { i++ } } return result}func min(a int, b int) int { if a &amp;gt; b { return b } return a}func max(a int, b int) int { if a &amp;gt; b { return a } return b}" }, { "title": "leetCode Day38", "url": "/posts/leetCode-Day38/", "categories": "leetCode", "tags": "Tang", "date": "2022-12-09 00:00:00 +0800", "snippet": "Unique Paths題目:有一個矩陣原點在0,0,有寬m長n,終點為m-1,n-1,只能向右或向下走,求走到終點有幾種方法解法:設定原點和往下到底和往右到底為1,任意點為左邊加上面的值,即可求得終點 codefunc uniquePaths(m int, n int) int { var dp [][]int dp = append(dp, []int{1}) for i := 1; i &amp;lt; m; i++ { dp = append(dp, []int{1}) } for j := 1; j &amp;lt; n; j++ { dp[0] = append(dp[0], 1) } for i:= 1; i &amp;lt; m; i++ { for j := 1; j &amp;lt; n; j++ { dp[i] = append(dp[i], dp[i - 1][j] + dp[i][j - 1]) } } return dp[m - 1][n - 1]}Construct Binary Tree from Preorder and Inorder Traversal題目:有兩個數字陣列preorder和inorder,其中preorder代表二分樹的前序遍歷,inorder代表二分樹的中序遍歷,求二分樹為何解法:因為前序遍歷為中左右,所以preorder[0]代表了root的值,然後中序遍歷為左中右,所以我們找到preorder[0]在inorder的index,此index前代表了在樹的左邊,index後代表在樹的右邊,遞迴方法就可以建出此樹,如果preorder或inorder為空的話,返回空 code/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */func buildTree(preorder []int, inorder []int) *TreeNode { if len(preorder) == 0 || len(inorder) == 0 { return nil } rootVal := preorder[0] result := &amp;amp;TreeNode{Val: rootVal} rootIdx := 0 for rootIdx &amp;lt; len(inorder) { if inorder[rootIdx] == rootVal { break } rootIdx++ } result.Left = buildTree(preorder[1:], inorder[:rootIdx]) result.Right = buildTree(preorder[rootIdx + 1:], inorder[rootIdx + 1:]) return result}" }, { "title": "leetCode Day37", "url": "/posts/leetCode-Day37/", "categories": "leetCode", "tags": "Tang", "date": "2022-12-08 00:00:00 +0800", "snippet": "Subsets題目:有一個數字陣列,裡面的數字都不重複,組合成數字所有排列組合的矩陣解法:使用遞歸,將每個組合找出來並存入結果裡面,最後返回結果 codefunc subsets(nums []int) [][]int { var result [][]int result = append(result, []int{}) return set(nums, 0, []int{}, result)}func set(nums []int, j int, cur []int, result [][]int) [][]int { for i := j; i &amp;lt; len(nums); i++ { cur = append(cur, nums[i]) copyCur := make([]int, len(cur)) copy(copyCur, cur) result = append(result, copyCur) result = set(nums, i + 1, cur, result) cur = cur[:len(cur) - 1] } return result}Binary Tree Right Side View題目:有一個二分樹,把每一層最右邊的樹組成陣列解法:如果節點為空跳過,判斷結果的長度和樹的層級相同的話,將節點的值存入結果中,優先執行右節點,在執行左節點,確保第一次進入下一層的值為最右的節點 code/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */func rightSideView(root *TreeNode) []int { var result []int return search(root, result, 0)}func search(root *TreeNode, result []int, level int) []int { if root == nil { return result } if level == len(result) { result = append(result, root.Val) } result = search(root.Right, result, level + 1) result = search(root.Left, result, level + 1) return result}Longest Palindromic Substring題目:有一個字串,求最大的回文字串解法:以每個字串為基準,看是否有奇數回文或偶數回文,奇數回文為基準點左右是否相同,偶數回文為基準點和基準點右邊是否相同,如果相同左邊減一右邊加一,直到不相同為止,即可求出最大回文字串 codefunc longestPalindrome(s string) string { var result string var tmp string for i := 0; i &amp;lt; len(s); i++ { tmp = even(s, i) if len(tmp) &amp;gt; len(result) { result = tmp } tmp = odd(s, i) if len(tmp) &amp;gt; len(result) { result = tmp } } return result}func even(s string, i int) string { var ans string left := i right := i + 1 for left &amp;gt;= 0 &amp;amp;&amp;amp; right &amp;lt; len(s) { if s[left] != s[right] { break } ans = s[left:right + 1] left-- right++ } return ans}func odd(s string, i int) string { var ans string ans = s[i:i + 1] left := i - 1 right := i + 1 for left &amp;gt;= 0 &amp;amp;&amp;amp; right &amp;lt; len(s) { if s[left] != s[right] { break } ans = s[left:right + 1] left-- right++ } return ans}" }, { "title": "leetCode Day36", "url": "/posts/leetCode-Day36/", "categories": "leetCode", "tags": "Tang", "date": "2022-12-07 00:00:00 +0800", "snippet": "Spiral Matrix題目:給一個數字矩陣,以螺旋的方式返回矩陣內所有元素解法:先找出x和y的初始點和終點,再寫四個方法分別為由左至右,由上至下,由右至左,由下至上,迴圈直到矩陣內沒有數字,則返回結果 codefunc spiralOrder(matrix [][]int) []int { var result []int y := len(matrix) - 1 x := len(matrix[0]) - 1 return oneOrder(matrix, 0, 0, x, y, result)}func oneOrder(matrix [][]int, i int, j int, x int, y int, result []int) []int { if i &amp;gt; x { return result } for k := i; k &amp;lt;= x; k++ { result = append(result, matrix[j][k]) } return twoOrder(matrix, i, j + 1, x, y, result)}func twoOrder(matrix [][]int, i int, j int, x int, y int, result []int) []int { if j &amp;gt; y { return result } for k := j; k &amp;lt;= y; k++ { result = append(result, matrix[k][x]) } return threeOrder(matrix, i, j, x - 1, y, result)}func threeOrder(matrix [][]int, i int, j int, x int, y int, result []int) []int { if i &amp;gt; x { return result } for k := x; k &amp;gt;= i; k-- { result = append(result, matrix[y][k]) } return fourOrder(matrix, i, j, x, y - 1, result)}func fourOrder(matrix [][]int, i int, j int, x int, y int, result []int) []int { if j &amp;gt; y { return result } for k := y; k &amp;gt;= j; k-- { result = append(result, matrix[k][i]) } return oneOrder(matrix, i + 1, j, x, y, result)}" }, { "title": "leetCode Day35", "url": "/posts/leetCode-Day35/", "categories": "leetCode", "tags": "Tang", "date": "2022-12-06 00:00:00 +0800", "snippet": "String to Integer (atoi)題目:將字串轉換成數字解法:先判斷字串長度為0的話返回0,然後將前面的空白去除,在判斷當前是否為正或負,接下來進入數字判斷,如果數字比最大值除以10還大或是數字等於最大值並且當前數字大於7的話,返回最大值或最小值,如果沒有返回數字 codefunc myAtoi(s string) int { idx := 0 sign := 1 total := 0 if len(s) == 0 { return 0 } for len(s) &amp;gt; idx &amp;amp;&amp;amp; s[idx] == &#39; &#39; { idx++ } if len(s) &amp;gt; idx &amp;amp;&amp;amp; (s[idx] == &#39;-&#39; || s[idx] == &#39;+&#39;) { if s[idx] == &#39;-&#39; { sign = -1 } idx++ } for len(s) &amp;gt; idx { digit := s[idx] - &#39;0&#39; if digit &amp;lt; 0 || digit &amp;gt; 9 { break } if math.MaxInt32 / 10 &amp;lt; total || math.MaxInt32 / 10 == total &amp;amp;&amp;amp; math.MaxInt32 % 10 &amp;lt; digit { if sign == 1 { return math.MaxInt32 } return math.MinInt32 } total = 10 * total + int(digit) idx++ } return sign * total}" }, { "title": "leetCode Day34", "url": "/posts/leetCode-Day34/", "categories": "leetCode", "tags": "Tang", "date": "2022-12-05 00:00:00 +0800", "snippet": "Partition Equal Subset Sum題目:有一個數字陣列,將陣列分成兩個,兩陣列總和相同,返回true解法:先判斷陣列長度為1的話返回false,算出陣列總和,因為需要分成兩個和相同的陣列,所以和一定為偶數,如果為基數返回false,使用動態規劃,找出和除2是否存在於數列組合中 codefunc canPartition(nums []int) bool { if len(nums) == 1 { return false } var sum int for _, value := range nums { sum += value } if sum % 2 == 1 { return false } sum /= 2 dp := make([]bool, sum + 1) dp[0] = true var tmpSum int for _, value := range nums { tmpSum += value for i := sum; i &amp;gt;= 0; i-- { if i &amp;gt;= value { dp[i] = dp[i] || dp[i-value] } } } return dp[sum]}" }, { "title": "leetCode Day33", "url": "/posts/leetCode-Day33/", "categories": "leetCode", "tags": "Tang", "date": "2022-12-04 00:00:00 +0800", "snippet": "Accounts Merge題目:有一個字串矩陣,第一個字串為姓名,後面為信箱,如果遇到姓名與信箱有一樣代表為同一個人,需把信箱合併,信箱需排序解法:設定一個信箱的陣列,裡面存的是信箱屬於哪個帳號,如果信箱之前就存在過的話,把之前擁有者的所屬換為現在的所屬,之後我們將屬於同一個帳號的連結起來,最後組成題目要的格式並將信做作排序 codefunc accountsMerge(accounts [][]string) [][]string { emailMap := make(map[string]int) indexConnections := make([]int, len(accounts)) for i := range indexConnections { indexConnections[i] = i } for accountIdx, emails := range accounts { for i := 1; i &amp;lt; len(emails); i++ { if existIdx, exist := emailMap[emails[i]]; exist { for { if indexConnections[existIdx] == existIdx { indexConnections[existIdx] = accountIdx break } existIdx = indexConnections[existIdx] } } else { emailMap[emails[i]] = accountIdx } } } for i := len(indexConnections)-1; i &amp;gt;= 0; i-- { indexConnections[i] = indexConnections[indexConnections[i]] } magic := make(map[int][]string) for email, index := range emailMap { if _, exist := magic[indexConnections[index]]; !exist { magic[indexConnections[index]] = []string{accounts[index][0]} } magic[indexConnections[index]] = append(magic[indexConnections[index]], email) } retSlice := make([][]string, 0, len(magic)) for _, v := range magic { sort.Strings(v[1:]) retSlice = append(retSlice, v) } return retSlice}Sort Colors題目:有一個數字陣列,裡面只有0,1,2,0代表紅色,1代表白色,2代表藍色,求紅白藍排序解法:定義左跟右還有正在執行的i三個變數,左和i為0,右為陣列長度-1,如果陣列i為0的話,需要跟左邊互換,左和i都+1,如果陣列i為2的話,需要和右邊互換,右邊-1,如果陣列i為1,i+1 codefunc sortColors(nums []int) { left := 0 right := len(nums) - 1 i := 0 for i &amp;lt;= right { if nums[i] == 0 { nums[left], nums[i] = nums[i], nums[left] left++ i++ } else if nums[i] == 2 { nums[i], nums[right] = nums[right], nums[i] right-- } else { i++ } }}Word Break題目:有一個字串,和一個字串陣列,如果字串能被字串陣列所組成,回傳true,不能回傳false,字串陣列中的字串沒有使用次數解法:使用動態規劃,如果字串在字典裡面有的話,就設定為true,最後看字串是否為true codefunc wordBreak(s string, wordDict []string) bool { dp := make([]bool, len(s) + 1) dp[0] = true dict := make(map[string]int) for _, value := range wordDict { dict[value] = 1 } for i := 1; i &amp;lt;= len(s); i++ { for j := 0; j &amp;lt; i; j++ { if dp[j] { substr := s[j:i] if _, ok := dict[substr]; ok { dp[i] = true; break } } } } return true}" }, { "title": "leetCode Day32", "url": "/posts/leetCode-Day32/", "categories": "leetCode", "tags": "Tang", "date": "2022-12-02 00:00:00 +0800", "snippet": "Time Based Key-Value Store題目:以時間儲存的key-value,set的timestamp皆為正時間序解法:設定一個key裡面儲存了value和timestamp,設定時將timestamp和value儲存至key中,get時如果key不存在或是傳入的timestamp比儲存的timestamp小的話,返回空,如果比較大的話,使用binary search找出最大小於timestamp的值 codetype TimeValue struct { Value string Timestamp int}type TimeMap struct { m map[string][]TimeValue}func Constructor() TimeMap { return TimeMap{m: make(map[string][]TimeValue)}}func (this *TimeMap) Set(key string, value string, timestamp int) { if _, ok := this.m[key]; !ok { this.m[key] = []TimeValue{} } this.m[key] = append(this.m[key], TimeValue{value, timestamp,})}func (this *TimeMap) Get(key string, timestamp int) string { if len(this.m[key]) == 0 || this.m[key][0].Timestamp &amp;gt; timestamp { return &quot;&quot; } left := 0 right := len(this.m[key]) for left &amp;lt; right { mid := (left + right) / 2 if this.m[key][mid].Timestamp == timestamp { return this.m[key][mid].Value } if this.m[key][mid].Timestamp &amp;gt; timestamp { right = mid } else { left = mid + 1 } } return this.m[key][right - 1].Value}/** * Your TimeMap object will be instantiated and called as such: * obj := Constructor(); * obj.Set(key,value,timestamp); * param_2 := obj.Get(key,timestamp); */" }, { "title": "leetCode Day31", "url": "/posts/leetCode-Day31/", "categories": "leetCode", "tags": "Tang", "date": "2022-12-01 00:00:00 +0800", "snippet": "Lowest Common Ancestor of a Binary Tree題目:有一個二分樹,給兩個節點,找出最小的共同節點解法:判斷節點是否為空或是p或是q,如果是的話返回該節點,將根節點的左節點和右節點都判斷p和q是否為根節點,如果一個為空,共同的節點就為另一個節點,如果都不為空,就為該節點 code/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */ func lowestCommonAncestor(root, p, q *TreeNode) *TreeNode { if root == nil || root == p || root == q { return root } left := lowestCommonAncestor(root.Left, p, q) right := lowestCommonAncestor(root.Right, p, q) if left == nil { return right } if right == nil { return left } return root }" }, { "title": "leetCode Day30", "url": "/posts/leetCode-Day30/", "categories": "leetCode", "tags": "Tang", "date": "2022-11-30 00:00:00 +0800", "snippet": "Permutations題目:有一個數字陣列,回傳所有的組合解法: codefunc permute(nums []int) [][]int { var cur []int var result [][]int visited := make(map[int]int) search(nums, &amp;amp;visited, &amp;amp;cur, &amp;amp;result) return result}func search(nums []int, visited *map[int]int, cur *[]int, result *[][]int) { if len(nums) == len(*cur) { cpycur := make([]int, len(*cur)) copy(cpycur, *cur) *result = append(*result, cpycur) } for i := 0; i &amp;lt; len(nums); i++ { if value, ok := (*visited)[i]; ok &amp;amp;&amp;amp; value == 1 { continue } (*visited)[i] = 1 *cur = append(*cur, nums[i]) search(nums, visited, cur, result) (*visited)[i] = 0 *cur = (*cur)[:len(*cur) - 1] }}Merge Intervals題目:有一組數字矩陣,將有重複的部分合併解法:如果當前的結束數字大於等於下一個陣列的開始數字,結束數字為大的值,遞迴 codefunc merge(intervals [][]int) [][]int { if len(intervals) == 1 { return intervals } var result [][]int sort.Slice(intervals, func(i, j int) bool { return intervals[i][0] &amp;lt; intervals[j][0] }) cur := intervals[0] for i := 1; i &amp;lt; len(intervals); i++ { if cur[1] &amp;gt;= intervals[i][0] { cur[1] = max(cur[1], intervals[i][1]) } else { result = append(result, cur) cur = intervals[i] } if i == len(intervals) - 1 { result = append(result, cur) } } return result}func max(a int, b int) int { if a &amp;gt; b { return a } return b}" }, { "title": "leetCode Day29", "url": "/posts/leetCode-Day29/", "categories": "leetCode", "tags": "Tang", "date": "2022-11-29 00:00:00 +0800", "snippet": "Search in Rotated Sorted Array題目:有一個旋轉排序的數字陣列,找出target是否存在陣列中解法:使用二分法找到中間值,如果中間值,如果中間值比左邊的值還大的話,代表左邊是排序的,判斷target是否在左邊到中間之間,如果是的話右邊為中間-1,如果不是左邊為中間+1,如果中間值比左邊的值還要小的話,因為中間至右邊為排序的,判斷target是否在中間和右邊之間,如果是的話,左邊為中間+1,如果不是右邊為中間-1 codefunc search(nums []int, target int) int { left := 0 right := len(nums) - 1 for left &amp;lt;= right { mid := (left + right) / 2 if nums[mid] == target { return mid } if nums[mid] &amp;gt; nums[left] { if nums[mid] &amp;gt; target &amp;amp;&amp;amp; target &amp;gt;= nums[left] { right = mid - 1 } else { left = mid + 1 } } else { if target &amp;gt; nums[mid] &amp;amp;&amp;amp; nums[right] &amp;gt;= target { left = mid + 1 } else { right = mid - 1 } } } return -1}Combination Sum題目:有一組數字陣列,裡面有不同的數字,求所有數字組合為target的數字組合,同一個數字可以使用無線多次解法:使用深度搜尋法,取得所有的組合 codefunc combinationSum(candidates []int, target int) [][]int { var result [][]int var cur []int search(candidates, 0, target, &amp;amp;cur, &amp;amp;result) return result}func search(candidates []int, idx int, target int, cur *[]int, result *[][]int) { if target == 0 { cpycur := make([]int, len(*cur)) copy(cpycur, *cur) *result = append(*result, cpycur) } for i := idx; i &amp;lt; len(candidates); i++ { if candidates[i] &amp;gt; target { continue } *cur = append(*cur, candidates[i]) search(candidates, i, target - candidates[i], cur, result) *cur = (*cur)[:len(*cur)-1] }}" }, { "title": "leetCode Day28", "url": "/posts/leetCode-Day28/", "categories": "leetCode", "tags": "Tang", "date": "2022-11-28 00:00:00 +0800", "snippet": "Rotting Oranges題目:有一個矩陣,2代表壞掉的橘子,1代表新鮮的橘子,0代表沒有橘子,過一天,壞掉的橘子會朝相鄰的新鮮橘子讓他壞掉,求最短多久會只剩下壞橘子,如果還有新鮮的橘子回傳-1解法:先把一開始壞掉的橘子找出來,再找出壞掉橘子旁邊是否為新鮮的橘子,如果為新鮮的橘子,將橘子設定為壞掉的,然後將座標存入queue中,最為下一層的壞橘子,值到queue為空 codefunc orangesRotting(grid [][]int) int { var result int var queue [][]int var fresh int m := len(grid) n := len(grid[0]) for i := 0; i &amp;lt; m; i++ { for j := 0; j &amp;lt; n; j++ { if grid[i][j] == 2 { queue = append(queue, []int{i, j}) } if grid[i][j] == 1 { fresh++ } } } for len(queue) &amp;gt; 0 &amp;amp;&amp;amp; fresh &amp;gt; 0 { result++ size := len(queue) for i :=0; i &amp;lt; size; i++ { cur := queue[i] if bfs(grid, cur[0] + 1, cur[1], m, n) { fresh-- grid[cur[0] + 1][cur[1]] = 2 queue = append(queue, []int{cur[0] + 1, cur[1]}) } if bfs(grid, cur[0] - 1, cur[1], m, n) { fresh-- grid[cur[0] - 1][cur[1]] = 2 queue = append(queue, []int{cur[0] - 1, cur[1]}) } if bfs(grid, cur[0], cur[1] + 1, m, n) { fresh-- grid[cur[0]][cur[1] + 1] = 2 queue = append(queue, []int{cur[0], cur[1] + 1}) } if bfs(grid, cur[0], cur[1] - 1, m, n) { fresh-- grid[cur[0]][cur[1] - 1] = 2 queue = append(queue, []int{cur[0], cur[1] - 1}) } } queue = queue[size:] } if fresh &amp;gt; 0 { return -1 } return result;}func bfs(grid [][]int, x int, y int, m int, n int) bool { if x &amp;gt;= 0 &amp;amp;&amp;amp; x &amp;lt; m &amp;amp;&amp;amp; y &amp;gt;= 0 &amp;amp;&amp;amp; y &amp;lt; n &amp;amp;&amp;amp; grid[x][y] == 1 { return true } return false}" }, { "title": "leetCode Day27", "url": "/posts/leetCode-Day27/", "categories": "leetCode", "tags": "Tang", "date": "2022-11-27 00:00:00 +0800", "snippet": "Validate Binary Search Tree題目:驗證是否為二分搜尋樹解法:設定最大值為無限大,最小值為負無限大,每個節點的值會在最大和最小值中間,左節點時最大值要換成父節點的值,右節點時最小時要換成父節點的值,都有符合的話就為二分搜尋樹 code/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */func isValidBST(root *TreeNode) bool { max := math.MaxInt64 min := math.MinInt64 return check(root.Left, root.Val, min) &amp;amp;&amp;amp; check(root.Right, max, root.Val)}func check(root *TreeNode, max int, min int) bool { if root == nil { return true } if root.Val &amp;lt; max &amp;amp;&amp;amp; root.Val &amp;gt; min { return check(root.Left, root.Val, min) &amp;amp;&amp;amp; check(root.Right, max, root.Val) } else { return false } return true}Number of Islands題目:有一個矩陣是由1,0組成,1代表陸地,0代表海洋,求有幾座島嶼,1相鄰為同一座島嶼解法:使用深度搜尋法,將跑過的陸地設為0,當跑到新的陸地時,結果+1 codefunc numIslands(grid [][]byte) int { var result int m := len(grid) n := len(grid[0]) for x := 0; x &amp;lt; m; x++ { for y := 0; y &amp;lt; n; y++ { if grid[x][y] == &#39;1&#39; { result += 1 dfs(&amp;amp;grid, x, y, m, n) } } } return result}func dfs(grid *[][]byte, x int, y int, m int, n int) { if x &amp;lt; 0 || x &amp;gt;= m || y &amp;lt; 0 || y &amp;gt;= n || (*grid)[x][y] == &#39;0&#39; { return } (*grid)[x][y] = &#39;0&#39; dfs(grid, x + 1, y, m, n) dfs(grid, x - 1, y, m, n) dfs(grid, x, y + 1, m, n) dfs(grid, x, y - 1, m, n)}" }, { "title": "leetCode Day26", "url": "/posts/leetCode-Day26/", "categories": "leetCode", "tags": "Tang", "date": "2022-11-26 00:00:00 +0800", "snippet": "Product of Array Except Self題目:一個數字陣列,算出數字總和,除了自己解法:算出每個點左邊的總和,和右邊的總和,兩個相加 codefunc productExceptSelf(nums []int) []int { length := len(nums) result := make([]int, length) result[0] = 1 for i := 1; i &amp;lt; length; i++ { result[i] = result[i - 1] * nums[i - 1] } right := 1 for i := length - 1; i &amp;gt;= 0; i-- { result[i] *= right right *= nums[i] } return result}Min Stack題目:最小棧,有新增,拋出,顯示最上面的值,顯示最小值的功能解法: codetype HeadStack struct { Val int Min int Next *HeadStack}func NewHeadStack(val int, min int, stack *HeadStack) *HeadStack { return &amp;amp;HeadStack{ Val: val, Min: min, Next: stack, }}type MinStack struct { head *HeadStack}func Constructor() MinStack { return MinStack{head: nil}}func (this *MinStack) Push(val int) { if this.head == nil { this.head = NewHeadStack(val, val, nil) } else { this.head = NewHeadStack(val, min(val, this.head.Min), this.head) }}func (this *MinStack) Pop() { this.head = this.head.Next}func (this *MinStack) Top() int { return this.head.Val}func (this *MinStack) GetMin() int { return this.head.Min}func min(a int, b int) int { if a &amp;gt; b { return b } return a}/** * Your MinStack object will be instantiated and called as such: * obj := Constructor(); * obj.Push(val); * obj.Pop(); * param_3 := obj.Top(); * param_4 := obj.GetMin(); */" }, { "title": "leetCode Day25", "url": "/posts/leetCode-Day25/", "categories": "leetCode", "tags": "Tang", "date": "2022-11-25 00:00:00 +0800", "snippet": "Implement Trie (Prefix Tree)題目:前綴樹,根節點不包含字符,每一個節點都只有一個字符解法:定義樹結構,有children有26個字母的樹結構和是否為結束的狀態,Insert時就跑字串,如果不存在於樹結構中,就建立樹結構,最後的樹結構的狀態為true,Search時就跑字串,如果字串不存在於樹結構中就返回false,如果字串跑完,就返回該樹結構的狀態,StartsWith時就跑字串,如果字串不存在於陣列中返回false,如果都存在返回true codetype Trie struct { children [26]*Trie isEnd bool}func Constructor() Trie { return Trie{}}func (this *Trie) Insert(word string) { curr := this for _, value := range word { idx := value - &#39;a&#39; if curr.children[idx] == nil { curr.children[idx] = &amp;amp;Trie{} } curr = curr.children[idx] } curr.isEnd = true}func (this *Trie) Search(word string) bool { curr := this for _, value := range word { idx := value - &#39;a&#39; if curr.children[idx] == nil { return false } curr = curr.children[idx] } return curr.isEnd}func (this *Trie) StartsWith(prefix string) bool { curr := this for _, value := range prefix { idx := value - &#39;a&#39; if curr.children[idx] == nil { return false } curr = curr.children[idx] } return true}/** * Your Trie object will be instantiated and called as such: * obj := Constructor(); * obj.Insert(word); * param_2 := obj.Search(word); * param_3 := obj.StartsWith(prefix); */Coin Change題目:有一個數字陣列代表了不同幣值的硬幣,需要找出符合金額的最少硬幣數量解法:使用DP,預設1至amount的值都為amount+1,取出coins陣列,將每個值都會為該點和(該點-coin)的值+1的最小值,最後DP[amount]就為最小的硬幣數量 codefunc coinChange(coins []int, amount int) int { dp := make([]int, amount + 1) for i := 1; i &amp;lt;= amount; i++ { dp[i] = amount + 1 } for _, coin := range coins { for i := coin; i &amp;lt;= amount; i++ { dp[i] = min(dp[i], dp[i - coin] + 1) } } if dp[amount] == amount + 1 { return -1 } return dp[amount]}func min (a int, b int) int { if a &amp;gt; b { return b } return a}" }, { "title": "leetCode Day24", "url": "/posts/leetCode-Day24/", "categories": "leetCode", "tags": "Tang", "date": "2022-11-24 00:00:00 +0800", "snippet": "Evaluate Reverse Polish Notation題目:計算反向波蘭表示法中算數表達式的值。解法:使用queue將數字存入queue中,然後遇到運算符號時,將queue中最後兩個數字取出,並算出結果,再丟回queue中,最後queue[0]為答案 codefunc evalRPN(tokens []string) int { var result int var queue []int for _, value := range tokens { switch value { case &quot;+&quot;: length := len(queue) result = queue[length - 2] + queue[length - 1] queue = queue[:len(queue)-2] queue = append(queue, result) case &quot;-&quot;: length := len(queue) result = queue[length - 2] - queue[length - 1] queue = queue[:len(queue)-2] queue = append(queue, result) case &quot;*&quot;: length := len(queue) result = queue[length - 2] * queue[length - 1] queue = queue[:len(queue)-2] queue = append(queue, result) case &quot;/&quot;: length := len(queue) result = queue[length - 2] / queue[length - 1] queue = queue[:len(queue)-2] queue = append(queue, result) default: num, _ := strconv.Atoi(value) queue = append(queue, num) } } return queue[0]}Course Schedule題目:有總共numCourses個課程,有一個陣列,裡面給你一個先決條件,其中prerequisites[i] = [ai, bi]表示如果你想修ai這門課,並須先修課程bi,判斷課程是否能被修完解法:將矩陣轉換成圖形,如果圖形為一個環的話,代表課程沒有辦法修完,如果圖形有終點代表,課程能被修完 codefunc canFinish(numCourses int, prerequisites [][]int) bool { visited := make([]int, numCourses) next := make([][]int, numCourses) for _, value := range prerequisites { next[value[0]] = append(next[value[0]], value[1]) } for key := range next { if dfs(key, visited, next) == false { return false } } return true}func dfs(key int, visited []int, next [][]int) bool { if visited[key] == 1 { return true } if visited[key] == 2 { return false } visited[key] = 2 for _, value := range next[key] { if dfs(value, visited, next) == false { return false } } visited[key] = 1 return true}" }, { "title": "leetCode Day23", "url": "/posts/leetCode-Day23/", "categories": "leetCode", "tags": "Tang", "date": "2022-11-23 00:00:00 +0800", "snippet": "Longest Substring Without Repeating Characters題目:給一個二分樹,返回節點級別的順序遍歷解法:定義一個空矩陣和節點級別,遞歸,如果二分樹為空的話,返回結果,如果結果矩陣的長度比節點級別+1還小的話,將空陣列塞入矩陣,將節點值塞入矩陣中,遍歷左節點和右節點,節點級別需+1 code/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */func levelOrder(root *TreeNode) [][]int { var result [][]int return getResult(root, result, 0)}func getResult(root *TreeNode, result [][]int, level int) [][]int { if root == nil { return result } if len(result) &amp;lt; level + 1 { result = append(result, []int{}) } result[level] = append(result[level], root.Val) result = getResult(root.Left, result, level + 1) result = getResult(root.Right, result, level + 1) return result}Clone Graph題目:複製一個給定的 graph解法:使用bfs,將連接的兩點存入queue中,每次從queue中拋出第一個值,並將此值的連接兩個點存入queue中,如果此點已經執行過,就不再重複執行,直到queue為空 code/** * Definition for a Node. * type Node struct { * Val int * Neighbors []*Node * } */func cloneGraph(node *Node) *Node { if node == nil { return nil } visited := make(map[*Node]*Node) queue := []*Node{node} visited[node] = &amp;amp;Node{Val: node.Val} for len(queue) &amp;gt; 0 { pop := queue[0] queue = queue[1:] for _, value := range pop.Neighbors { if _, ok := visited[value]; !ok { visited[value] = &amp;amp;Node{Val:value.Val} queue = append(queue, value) } visited[pop].Neighbors = append(visited[pop].Neighbors, visited[value]) } } return visited[node]}" }, { "title": "leetCode Day22", "url": "/posts/leetCode-Day22/", "categories": "leetCode", "tags": "Tang", "date": "2022-11-22 00:00:00 +0800", "snippet": "Longest Substring Without Repeating Characters題目:給一個字串,找出最長的子字串,子字串不能有重複的字解法:定義一個陣列用來儲存字母在哪個位置出現過,字串跑迴圈,如果該字母沒有在陣列中出現,把字母存入陣列中,長度為max(之前的長度,跑到第幾個位置-前面最大的重複長度+1),如果字母有出現在陣列中,重複長度為max(重複長度,該字母上次出現的位置+1) codefunc lengthOfLongestSubstring(s string) int { var res int var j int arr := make(map[rune]int) for key, value := range s { if _, ok := arr[value]; ok { j = max(j, arr[value] + 1) } arr[value] = key res = max(res, key - j + 1) } return res}func max(a int, b int) int { if a &amp;gt; b { return a } return b}3Sum題目:有一個非排序數字陣列,求其中三個數的總和為0,三個數的位置皆不同,將符合的數組成矩陣返回解法:先進行排序,遞回陣列,如果該值在上一次出現過,就跳過,設定後兩數的點為,該點+1(j)和最後一點(k),如果j&amp;lt;k就持續執行,算出三個座標的總和(s),s如果大於0,表示後兩數和過大,k--,s如果小於0,表示後兩數和過小,j++,如果s等於0,將三點的值丟入結果矩陣中,如果j和j+1的值相同的話,j++,如果k和k-1的值想同的話,k-- codefunc threeSum(nums []int) [][]int { var result [][]int var jdx int var kdx int var s int sort.Ints(nums) for idx := 0; idx &amp;lt; len(nums); idx++ { if idx &amp;gt; 0 &amp;amp;&amp;amp; nums[idx] == nums[idx - 1] { continue } jdx = idx + 1 kdx = len(nums) - 1 for jdx &amp;lt; kdx { s = nums[idx] + nums[jdx] + nums[kdx] if s == 0 { result = append(result, []int{nums[idx], nums[jdx], nums[kdx]}) for jdx &amp;lt; kdx &amp;amp;&amp;amp; nums[jdx] == nums[jdx + 1] { jdx++ } for jdx &amp;lt; kdx &amp;amp;&amp;amp; nums[kdx] == nums[kdx - 1] { kdx-- } jdx++ kdx-- } else if s &amp;gt; 0 { kdx-- } else { jdx++ } } } return result}" }, { "title": "leetCode Day21", "url": "/posts/leetCode-Day21/", "categories": "leetCode", "tags": "Tang", "date": "2022-11-21 00:00:00 +0800", "snippet": "01 Matrix題目:有一個由0,1組成的矩陣,算出各點到0的最短距離,兩個點之間的距離為1解法:找出原矩陣值為0的點,將該點存入p矩陣中,並設定矩陣res,如果原矩陣點的值不為0,設定為最大值,為0的話設定為0,之後,如果p矩陣不為空的話,將p矩陣的點取出,跑相鄰的四的點,如果點的值為最大值,表示該點之前尚未走到過,該點為現在點的值+1,直到矩陣p跑完為空 codefunc updateMatrix(mat [][]int) [][]int { var result [][]int var q [][]int x, y := len(mat), len(mat[0]) for i := 0; i &amp;lt; x ; i++ { result = append(result, make([]int, y)) for j := 0; j &amp;lt; y; j++ { if mat[i][j] == 0 { q = append(q, []int{i, j}) result[i][j] = 0 } else { result[i][j] = x + y } } } for len(q) &amp;gt; 0 { p := q[0] q = q[1:] for _, value := range dis { m := p[0] + value[0] n := p[1] + value[1] if m &amp;gt;= 0 &amp;amp;&amp;amp; m &amp;lt; x &amp;amp;&amp;amp; n &amp;gt;= 0 &amp;amp;&amp;amp; n &amp;lt; y &amp;amp;&amp;amp; result[m][n] == x + y { result[m][n] = result[p[0]][p[1]] + 1 q = append(q, []int{m, n}) } } } return result}K Closest Points to Origin題目:一個矩陣有多個點,找出距離原點最短的K個點解法:使用快速收尋 codefunc kClosest(points [][]int, k int) [][]int { sort.Slice(points, func(i, j int) bool { return points[i][0] * points[i][0] + points[i][1] * points[i][1] &amp;lt; points[j][0] * points[j][0] + points[j][1] * points[j][1] }) return points[:k]}" }, { "title": "leetCode Day20", "url": "/posts/leetCode-Day20/", "categories": "leetCode", "tags": "Tang", "date": "2022-11-19 00:00:00 +0800", "snippet": "Insert Interval題目:有一個二維陣列,每個陣列中第一個數代表開始,第二個數代表結束,陣列是順序的,先在需要插入一個陣列,讓此二維陣列一樣維持順序排列解法:把陣列分成三段,陣列中結束的數字比插入陣列開始還小,和陣列中開始比插入陣列結束還大,都直接丟入陣列,如果陣列結束大於等於插入開始和陣列開始小於等於插入結束時,開始為兩陣列中開始的最小值,結束為兩陣列中結束的最大值,再將插入的陣列丟入陣列中 codefunc insert(intervals [][]int, newInterval []int) [][]int { var result [][]int i := 0 for i &amp;lt; len(intervals) &amp;amp;&amp;amp; intervals[i][1] &amp;lt; newInterval[0] { result = append(result, intervals[i]) i++ } for i &amp;lt; len(intervals) &amp;amp;&amp;amp; intervals[i][1] &amp;gt;= newInterval[0] &amp;amp;&amp;amp; intervals[i][0] &amp;lt;= newInterval[1] { if intervals[i][0] &amp;lt; newInterval[0] { newInterval[0] = intervals[i][0] } if intervals[i][1] &amp;gt; newInterval[1] { newInterval[1] = intervals[i][1] } i++ } result = append(result, newInterval) for i &amp;lt; len(intervals) &amp;amp;&amp;amp; intervals[i][0] &amp;gt; newInterval[1] { result = append(result, intervals[i]) i++ } return result}" }, { "title": "leetCode Day19", "url": "/posts/leetCode-Day19/", "categories": "leetCode", "tags": "Tang", "date": "2022-11-18 00:00:00 +0800", "snippet": "Maximum Subarray題目:有一個數字陣列,找出此陣列中的子陣列總和最大的值解法:跑迴圈,如果前面的總和為負數時,總和為0,從新計算總和,如果總和比最大值還大時,替換最大值 codefunc maxSubArray(nums []int) int { sum := nums[0]; max := nums[0]; for i:=1; i&amp;lt;len(nums); i++ { if sum &amp;lt; 0 { sum = 0 } sum += nums[i] if (sum &amp;gt; max) { max = sum } } return max}" }, { "title": "leetCode Day18", "url": "/posts/leetCode-Day18/", "categories": "leetCode", "tags": "Tang", "date": "2022-11-17 00:00:00 +0800", "snippet": "Subtree of Another Tree題目:給兩個二分樹,其中一個為另一個的子樹,返回true,不是返回false解法:每個節點都判斷是否和子樹相同,如果所有節點都不想同,返回false,如果有一個節點相同返回true code/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */func isSubtree(root *TreeNode, subRoot *TreeNode) bool { if root == nil { return false; } if isSame(root, subRoot) { return true; } return isSubtree(root.Left, subRoot) || isSubtree(root.Right, subRoot)}func isSame(root *TreeNode, subRoot *TreeNode) bool { if root == nil || subRoot == nil { return root == subRoot } if root.Val != subRoot.Val { return false } return isSame(root.Left, subRoot.Left) &amp;amp;&amp;amp; isSame(root.Right, subRoot.Right)}Squares of a Sorted Array題目:一個順序排列的數字陣列,陣列中的值平方在順序排序解法:因為陣列是有序的,所以平方的最大數,不是第一位,就是最後一位,因次我們從頭和尾一起找哪個數平方較大,直到陣列跑完可得答案 codefunc sortedSquares(nums []int) []int { arrLen := len(nums) s, e := 0, arrLen - 1 result := make([]int, arrLen) for i:=arrLen - 1; i &amp;gt;= 0; i-- { if int(math.Abs(float64(nums[s]))) &amp;gt; nums[e] { result[i] = nums[s] * nums[s] s++ } else { result[i] = nums[e] * nums[e] e-- } } return result}" }, { "title": "leetCode Day17", "url": "/posts/leetCode-Day17/", "categories": "leetCode", "tags": "Tang", "date": "2022-11-16 00:00:00 +0800", "snippet": "Convert Sorted Array to Binary Search Tree題目:給一個順序排列的數字陣列,將它轉換成高平衡的二收尋樹解法:找出陣列中間值,樹的左節點為中間值往左的陣列,樹的右節點為中間值往右的陣列,迴圈直到陣列跑完 code/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */func sortedArrayToBST(nums []int) *TreeNode { return sort(nums, 0, len(nums)-1)}func sort(nums []int, start int, end int) *TreeNode { if (start &amp;gt; end) { return nil } mid := (start + end) / 2 node := &amp;amp;TreeNode{ Val: nums[mid], Left: sort(nums, start, mid - 1), Right: sort(nums, mid + 1, end), } return node}Reverse Bits題目:給一個數字,將轉成二進制並反轉,回傳結果解法:預設結果為0,迴圈,結果左移,如果輸入為奇數,結果+1,輸入右移,跑32次迴圈,可得答案 codefunc reverseBits(num uint32) uint32 { var result uint32 for i:=0; i&amp;lt;32; i++ { result &amp;lt;&amp;lt;= 1 if num % 2 == 1 { result += 1 } num &amp;gt;&amp;gt;= 1 } return result}" }, { "title": "leetCode Day16", "url": "/posts/leetCode-Day16/", "categories": "leetCode", "tags": "Tang", "date": "2022-11-15 00:00:00 +0800", "snippet": "Missing Number題目:給一組數字陣列,由0至n,找出消失的數字解法:算出0至n的總和,跑迴圈總和減去數字,最後的數字,就為答案 codefunc missingNumber(nums []int) int { sum := (len(nums) + 1) * len(nums) / 2 for _, value := range nums { sum -= value } return sum}Palindrome Number題目:給一個整數,判斷整數是否為回文解法:判斷整數是否為負數,負數返回false,將整數取10的餘數,在除10,將整數翻轉,判斷反轉後的整數是否和原整數相同 codefunc isPalindrome(x int) bool { if x &amp;lt; 0 { return false } o, r := x, 0 for x &amp;gt; 0 { r = 10 * r + x % 10 x /= 10 } return r == o}" }, { "title": "leetCode Day15", "url": "/posts/leetCode-Day15/", "categories": "leetCode", "tags": "Tang", "date": "2022-11-14 00:00:00 +0800", "snippet": "Move Zeroes題目:給一個數字陣列,把所有的0移動到陣列最後,不要使用複製原陣列的方法解法:跑迴圈,如果字數為0,計算0出現幾次,如果不為0,和前面出現的第一個0換位子 codefunc moveZeroes(nums []int) { var tmp int zeroCount := 0 for i:=0; i&amp;lt;len(nums); i++ { if nums[i] == 0 { zeroCount++ } else { tmp = nums[i] nums[i] = 0 nums[i-zeroCount] = tmp } }}Symmetric Tree題目:給一個二分樹,判斷樹是不是對稱的解法: code/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */func isSymmetric(root *TreeNode) bool { return match(root.Left, root.Right)}func match(left *TreeNode, right *TreeNode) bool { if left == nil || right == nil { return left == right } if left.Val != right.Val { return false } return match(left.Left, right.Right) &amp;amp;&amp;amp; match(left.Right, right.Left)}" }, { "title": "leetCode Day14", "url": "/posts/leetCode-Day14/", "categories": "leetCode", "tags": "Tang", "date": "2022-11-13 00:00:00 +0800", "snippet": "Longest Common Prefix題目:一個陣列裡面有許多字串,找出這些字串的共同前綴,如果沒有返回空解法:先找出最短陣列的長度,跑迴圈判斷每個陣列的字母是否都一樣,把字串串起來,如果不一樣,返回字串 codefunc longestCommonPrefix(strs []string) string { var result string minLen := len(strs[0]) for key := range strs { if len(strs[key]) &amp;lt; minLen { minLen = len(strs[key]) } } for i:=0; i&amp;lt;minLen; i++ { str := &quot;&quot; for _, value := range strs { if str == &quot;&quot; { str = value[i:i+1] } else { if str != value[i:i+1] { return result } } } result = result + str } return result}Single Number題目:一個不為空的數字陣列,每個數字都會出現兩次,只有一個數字出現一次,找出該數字解法:陣列排序,如果偶數key的值和他下一個數字不相同的話,該數字就是獨立的數字,如果都相同,最後一個數為獨立的 codeimport &quot;sort&quot;func singleNumber(nums []int) int { sort.Ints(nums) for i:=0; i&amp;lt;len(nums)-1; i+=2 { if nums[i] != nums[i+1] { return nums[i] } } return nums[len(nums)-1]}Palindrome Linked List題目:有一個連結串,判斷是否回文解法:先用龜兔賽跑找出中間點,如果為奇數,第二段為中間數的下一個,將第二段反轉,跑迴圈判斷第二段跟第一段的值是否相同 code/** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */func isPalindrome(head *ListNode) bool { fast, slow := head, head for fast != nil &amp;amp;&amp;amp; fast.Next != nil { fast = fast.Next.Next slow = slow.Next } if fast != nil { slow = slow.Next } slow = reverse(slow) for slow != nil { if slow.Val != head.Val { return false } slow = slow.Next head = head.Next } return true}func reverse(head *ListNode) *ListNode { var tmp *ListNode for head != nil { next := head.Next head.Next = tmp tmp = head head = next } return tmp}" }, { "title": "leetCode Day13", "url": "/posts/leetCode-Day13/", "categories": "leetCode", "tags": "Tang", "date": "2022-11-12 00:00:00 +0800", "snippet": "Counting Bits題目:給一個正整數,返回從0至n的二進制,1出現的數量解法:n出現1的數字為n向右移動一格,就會是n/2無條件捨去,然後再被右移移除的那個數是1還是0,就會是n%2,每層的算法就會是f[n / 2] + n % 2 codefunc countBits(n int) []int { var result []int var num int result = append(result, 0) for i:=1; i&amp;lt;=n; i++ { num = result[i/2] + i % 2 result = append(result, num) } return result}Same Tree題目:給兩個二分樹,判斷這兩個是否相等解法:遞歸,如果p等於nil,q等於nil,返回true,如果p等於nil,q不等於nil,或是p不等於nil,q等於nil,返回false,如果p.Val不等於q.Val,返回false,每層都帶各自的左右節點,最後判斷,左右是否皆為true code/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */func isSameTree(p *TreeNode, q *TreeNode) bool { if p == nil &amp;amp;&amp;amp; q == nil { return true } if (p == nil &amp;amp;&amp;amp; q != nil) || (p != nil &amp;amp;&amp;amp; q == nil) { return false } if p.Val != q.Val { return false } return isSameTree(p.Left, q.Left) &amp;amp;&amp;amp; isSameTree(p.Right, q.Right)}Number of 1 Bits題目:給一個數字轉成二進制,會有幾個1解法:迴圈 num % 2, num / 2,如果num % 2為1的話,代表有1出現,一直跑到num為0,計算每層num%2的總和 codefunc hammingWeight(num uint32) int { var result int for num != 0 { result += int(num % 2) num = num / 2 } return result}" }, { "title": "leetCode Day12", "url": "/posts/leetCode-Day12/", "categories": "leetCode", "tags": "Tang", "date": "2022-11-11 00:00:00 +0800", "snippet": "Backspace String Compare題目:給兩個字串,如果兩個陣列相等回傳true,&#39;#&#39;為消除前一個字串解法: codefunc backspaceCompare(s string, t string) bool { x := len(s) - 1 y := len(t) - 1 count := 0 for true { for x &amp;gt;= 0 &amp;amp;&amp;amp; (s[x] == 35 || count &amp;gt; 0) { if s[x] != 35 { count-- } else { count++ } x-- } count = 0 for y &amp;gt;=0 &amp;amp;&amp;amp; (t[y] == 35 || count &amp;gt; 0) { if t[y] != 35 { count-- } else { count++ } y-- } if x &amp;gt;= 0 &amp;amp;&amp;amp; y &amp;gt;= 0 &amp;amp;&amp;amp; s[x] == t[y] { x-- y-- } else { break } } return x == -1 &amp;amp;&amp;amp; y == -1}" }, { "title": "leetCode Day11", "url": "/posts/leetCode-Day11/", "categories": "leetCode", "tags": "Tang", "date": "2022-11-10 00:00:00 +0800", "snippet": "Contains Duplicate題目:給一個數字陣列,如果任何一個數字出現最少兩次,返回成功,否則返回失敗解法:設定一個空陣列arr,將nums的值出現的次數,存入arr中,如果大於等於2,返回成功,否則返回失敗 codefunc containsDuplicate(nums []int) bool { arr := make(map[int]int) for _, value := range nums { arr[value]++ if arr[value] == 2 { return true } } return false}Roman to Integer題目:羅馬字母轉成數字解法:如果前一位比後一位小的話,變負的總和相加 codefunc romanToInt(s string) int { match := map[string]int { &quot;I&quot; : 1, &quot;V&quot; : 5, &quot;X&quot; : 10, &quot;L&quot; : 50, &quot;C&quot; : 100, &quot;D&quot; : 500, &quot;M&quot; : 1000, } var sum int for i:=0; i&amp;lt;len(s); i++ { if i != len(s) - 1 { if match[s[i:i+1]] &amp;lt; match[s[i+1:i+2]] { sum -= match[s[i:i+1]] } else { sum += match[s[i:i+1]] } } else { sum += match[s[i:i+1]] } } return sum}" }, { "title": "leetCode Day10", "url": "/posts/leetCode-Day10/", "categories": "leetCode", "tags": "Tang", "date": "2022-11-09 00:00:00 +0800", "snippet": "Middle of the Linked List題目:給一個連結串,找出中間的節點,如果中間節點有兩個的話,返回第二個節點解法:使用龜兔賽跑方式,fast走兩步,slow走一步,當fast走到終點時,slow剛好走到中間,返回slow code/** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */func middleNode(head *ListNode) *ListNode { fast, slow := head, head; for fast != nil &amp;amp;&amp;amp; fast.Next != nil { fast = fast.Next.Next slow = slow.Next } return slow}Maximum Depth of Binary Tree題目:求二分數的最大深度解法:每個節點的深度為左邊和右邊取最大值+1,如果左節點為空回傳0,右節點為空回傳0,每層跑完就能找到根節點的最大深度 code/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */func maxDepth(root *TreeNode) int { if root == nil { return 0 } left := maxDepth(root.Left) right := maxDepth(root.Right) return max(left, right) + 1}func max(a int, b int) int { if (a &amp;gt; b) { return a } return b}" }, { "title": "leetCode Day9", "url": "/posts/leetCode-Day9/", "categories": "leetCode", "tags": "Tang", "date": "2022-11-08 00:00:00 +0800", "snippet": "Add Binary題目:給兩個由0和1組成的字串,求這兩字串二進制相加為多少解法:兩字串算出長度,長度-1就會為個位數,兩字串個位數相加為總和,總和%2為字串結果,總和/2代表進位,持續執行,直到跑完兩字串 codefunc addBinary(a string, b string) string { var result string var carry int var sum int x := len(a) - 1 y := len(b) - 1 for x &amp;gt;= 0 || y &amp;gt;= 0 { sum = carry if x &amp;gt;= 0 { sum += int(a[x] - &#39;0&#39;) x-- } if y &amp;gt;= 0 { sum += int(b[y] - &#39;0&#39;) y-- } result = strconv.Itoa(sum % 2) + result carry = sum / 2 } if carry == 1 { result = strconv.Itoa(1) + result } return result}Diameter of Binary Tree題目:給一個二分樹,求樹的最大長度,路徑不一定會經過樹根解法:算出個節點左右的深度,距離為左右深度相加,就能找出最大深度 code/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */func diameterOfBinaryTree(root *TreeNode) int { var maxDiameter int depth(root, &amp;amp;maxDiameter) return maxDiameter}func depth(root *TreeNode, maxDiameter *int) int { if root == nil { return 0 } left := depth(root.Left, maxDiameter) right := depth(root.Right, maxDiameter) *maxDiameter = max(*maxDiameter, left + right) return max(left, right) + 1}func max(a int, b int) int { if (a &amp;gt; b) { return a } return b}#題目:解法: code" }, { "title": "leetCode Day8", "url": "/posts/leetCode-Day8/", "categories": "leetCode", "tags": "Tang", "date": "2022-11-07 00:00:00 +0800", "snippet": "Reverse Linked List題目:反轉鏈表解法: code/** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */func reverseList(head *ListNode) *ListNode { return reverse(head, nil)}func reverse(head *ListNode, newNode *ListNode) *ListNode { if (head == nil) { return newNode } next := head.Next head.Next = newNode return reverse(next, head)}Majority Element題目:有一個數字陣列,返回多數元素解法:先假設陣列第一個數是最多的數字(num),出現次數為1,跑迴圈,如果出現次數為0的話,表示該數字不是最多的數字,num為另一個數字,設定出現數字為1,如果陣列的值跟num一樣的話,count++,如果不一樣的話count-- codefunc majorityElement(nums []int) int { count := 1 num := nums[0] for i := 1; i &amp;lt; len(nums); i++ { if count == 0 { num = nums[i] count = 1 } else if nums[i] == num { count++ } else { count-- } } return num}#題目:解法: code" }, { "title": "leetCode Day7", "url": "/posts/leetCode-Day7/", "categories": "leetCode", "tags": "Tang", "date": "2022-11-06 00:00:00 +0800", "snippet": "Implement Queue using Stacks題目:使用兩個堆棧實現先進先出的佇列解法:因為是先進先出,所以定義了正反兩個陣列,在push的時候,如果反陣列為空,就把值丟進正陣列,如果反陣列不為空,先將反陣列反向丟回正陣列,在pop的時候,如果正陣列不為空,先將正陣列反向丟到反陣列中,取出反陣列中最後一個數字,在peek的時候,如果反陣列為空,輸出正陣列的第一個數,反陣列不為空,輸出反陣列最後一個數,empty的時候,如果正反兩陣列都不為空,回傳false codetype MyQueue struct { Input []int Output []int}func Constructor() MyQueue { return MyQueue{}}func (this *MyQueue) Push(x int) { for len(this.Output) != 0 { this.Input = append(this.Input, this.Output[len(this.Output) - 1]) this.Output = this.Output[:len(this.Output) - 1] } this.Input = append(this.Input, x)}func (this *MyQueue) Pop() int { for len(this.Input) != 0 { this.Output = append(this.Output, this.Input[len(this.Input) - 1]) this.Input = this.Input[:len(this.Input) - 1] } pop := this.Output[len(this.Output) - 1] this.Output = this.Output[:len(this.Output) - 1] return pop}func (this *MyQueue) Peek() int { if len(this.Output) == 0 { return this.Input[0] } return this.Output[len(this.Output) - 1]}func (this *MyQueue) Empty() bool { return len(this.Input) == 0 &amp;amp;&amp;amp; len(this.Output) == 0}/** * Your MyQueue object will be instantiated and called as such: * obj := Constructor(); * obj.Push(x); * param_2 := obj.Pop(); * param_3 := obj.Peek(); * param_4 := obj.Empty(); */First Bad Version題目:有一個1,2,3....,n的版本號,提供一個api可以查詢版本的好壞,找出最早出現壞的版本的版本號解法:跑迴圈,如果start&amp;lt;=end,mid = (start + end) / 2,如果mid的版本號為壞的,end = mid - 1,如果版本號為好的,start = end + 1,直到迴圈跑完,就可找到最早出現的壞版本 code/** * Forward declaration of isBadVersion API. * @param version your guess about first bad version * @return true if current version is bad * false if current version is good * func isBadVersion(version int) bool; */func firstBadVersion(n int) int { start, mid, version := 1, 0, 1 for start &amp;lt;= n { mid = (start + n) / 2 if isBadVersion(mid) { version = mid n = mid - 1 } else { start = mid + 1 } } return version}Ransom Note題目:給兩個字串, 判斷A陣列是否可以由B陣列組成解法:將兩字串出現字母的次數存入兩陣列中,如果A陣列字母出現的次數比B多的話,返回false codefunc canConstruct(ransomNote string, magazine string) bool { aArr, bArr := make(map[string]int), make(map[string]int) for key := range ransomNote { aArr[ransomNote[key:key + 1]]++ } for key := range magazine { bArr[magazine[key:key + 1]]++ } for key, value := range aArr { if bArr[key] &amp;lt; value { return false } } return true}#題目:爬梯子一次能爬1或2層,請問到n層總共有幾種方法解法:爬到n層會是n-1層+n-2層,所以定義第0層和第1層為1,跑迴圈算出第n層有幾種方法 codefunc climbStairs(n int) int { level := 2 arr := make(map[int]int) arr[0] = 1 arr[1] = 1 for level &amp;lt;= n { arr[level] = arr[level - 1] + arr[level - 2] level++ } return arr[level - 1]}Longest Palindrome題目:給你一串陣列,返回可組成最大回文的字母數量解法:算出出現奇數的數量,如果出現奇數數量 &amp;gt; 0,出現奇數數量 = 出現奇數數量 - 1,回文最大長度為總長度-出現奇數數量 codefunc longestPalindrome(s string) int { var oddCount int arr := make(map[string]int) for key := range s { arr[s[key:key + 1]]++ } for _, value := range arr { if value % 2 == 1 { oddCount++ } } if (oddCount &amp;gt; 0) { oddCount-- } return len(s) - oddCount}" }, { "title": "leetCode Day6", "url": "/posts/leetCode-Day6/", "categories": "leetCode", "tags": "Tang", "date": "2022-11-05 00:00:00 +0800", "snippet": "Lowest Common Ancestor of a Binary Search Tree題目:給一個二搜尋樹，給兩個此樹的不相同節點，找出最低共同祖先的節點解法: code/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */func lowestCommonAncestor(root, p, q *TreeNode) *TreeNode { maxValue := Max(p.Val, q.Val) minValue := Min(p.Val, q.Val) for root != nil { if root.Val &amp;gt; maxValue { root = root.Left } else if root.Val &amp;lt; minValue { root = root.Right } else { return root } } return nil}func Max(a, b int) int { if a &amp;gt; b { return a } return b}func Min(a, b int) int { if a &amp;gt; b { return b } return a}Balanced Binary Tree題目:給一個二分數, 判斷他的高度是否平衡解法:計算每一層樹的層級的差距,超過1的話,就是不平衡的 code/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */func isBalanced(root *TreeNode) bool { level := CalLevel(root) if level == -1 { return false } return true}func CalLevel(root *TreeNode) int { if root == nil { return 0 } leftLevel := CalLevel(root.Left) rightLevel := CalLevel(root.Right) if leftLevel == -1 || rightLevel == -1 { return -1 } levelDiff := leftLevel - rightLevel if levelDiff &amp;lt; -1 || levelDiff &amp;gt; 1 { return -1 } if leftLevel &amp;gt;= rightLevel { return leftLevel + 1 } else { return rightLevel + 1 }}Linked List Cycle題目:給一個鏈表,判斷這張表是否重複解法:定義fast為下兩個值,slow為下一個的值,循環直到如果fast的下一個或下兩個為空,結果為非重複,如果fast=slow的話,表示重複 code/** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */func hasCycle(head *ListNode) bool { if head == nil { return false } fast, slow := head, head for fast.Next != nil &amp;amp;&amp;amp; fast.Next.Next != nil { fast = fast.Next.Next slow = slow.Next if fast == slow { return true } } return false}" }, { "title": "leetCode Day5", "url": "/posts/leetCode-Day5/", "categories": "leetCode", "tags": "Tang", "date": "2022-11-04 00:00:00 +0800", "snippet": "Flood Fill題目:給一個二維陣列,每個欄位都有顏色,給一個座標需染成目標色,如果鄰近的座標顏色都相同的話,會一起被染成目標色解法: codefunc floodFill(image [][]int, sr int, sc int, color int) [][]int { if image[sr][sc] == color { return image } oldColor := image[sr][sc] m := len(image) n := len(image[0]) image[sr][sc] = color for _, value := range offset { x := sr + value[0] y := sc + value[1] if x &amp;gt;= 0 &amp;amp;&amp;amp; x &amp;lt; m &amp;amp;&amp;amp; y &amp;gt;= 0 &amp;amp;&amp;amp; y &amp;lt; n &amp;amp;&amp;amp; image[x][y] == oldColor { floodFill(image, x, y, color) } } return image}" }, { "title": "leetCode Day4", "url": "/posts/leetCode-Day4/", "categories": "leetCode", "tags": "Tang", "date": "2022-11-03 00:00:00 +0800", "snippet": "Valid Anagram題目:給兩個字串,如果這兩個字串裡面的字母從新組合都相同返回true,不同返回false解法:判斷兩個數的長度,如果不一樣,回傳false,將第一個字串的所有字母存入hash表出現次數,遍歷第二個字串,如果出現字數次數為0,回傳false,字母出現次數-- codefunc isAnagram(s string, t string) bool { if len(s) != len(t) { return false } tmp := make(map[rune]int) for _, value := range s { tmp[value]++ } for _, value := range t { if tmp[value] == 0 { return false } tmp[value]-- } return true}Binary Search題目:有一個數字陣列,找出目標值是否在陣列內,不在回傳-1,在的話回傳key, 空間複雜度O(log n)解法:使用二分法看中間值跟目標值比大小,目標值大的話,最小值為中間值+1,目標值小的話,最大值為中間值-1,直到找出值,或是跑完陣列 codefunc search(nums []int, target int) int { min, max, mid := 0, len(nums) - 1, 0 for min &amp;lt;= max { mid = (min + max) / 2 if nums[mid] &amp;gt; target { max = mid - 1 } else if nums[mid] &amp;lt; target { min = mid + 1 } else { return mid } } return -1}" }, { "title": "leetCode Day3", "url": "/posts/leetCode-Day3/", "categories": "leetCode", "tags": "Tang", "date": "2022-11-02 00:00:00 +0800", "snippet": "Valid Palindrome題目:有一個字串把所有字母轉成小寫,並忽略其他符號,只留字母和數字,由前往後讀和由後往前讀都相同,返回true,不相同返回false解法:先把字串改成小寫,跑迴圈從前面跟後面的值去做比對,如果值不是字母或數字就跳過這個值,最後都相同返回true,不相同返回false codefunc isPalindrome(s string) bool { x, y := 0, len(s) - 1 str := strings.ToLower(s) for x &amp;lt; y { if !isValid(str[x]) { x++ continue } if !isValid(str[y]) { y-- continue } if str[x] != str[y] { return false } x++ y-- } return true}func isValid(a byte) bool { if (a &amp;gt;= &#39;a&#39; &amp;amp;&amp;amp; a &amp;lt;= &#39;z&#39;) || (a &amp;gt;= &#39;A&#39; &amp;amp;&amp;amp; a &amp;lt;= &#39;Z&#39;) || (a &amp;gt;= &#39;0&#39; &amp;amp;&amp;amp; a &amp;lt;= &#39;9&#39;) { return true } return false}Invert Binary Tree題目:有一個二分樹,返回反轉的樹解法: code/** * Definition for a binary tree node. * type TreeNode struct { * Val int * Left *TreeNode * Right *TreeNode * } */func invertTree(root *TreeNode) *TreeNode { node := new(TreeNode) if root == nil { return root } node.Val = root.Val if root.Right != nil { node.Left = invertTree(root.Right) } else { node.Left = nil } if root.Left != nil { node.Right = invertTree(root.Left) } else { node.Right = nil } return node}" }, { "title": "leetCode Day2", "url": "/posts/leetCode-Day2/", "categories": "leetCode", "tags": "Tang", "date": "2022-11-01 00:00:00 +0800", "snippet": "Merge Two Sorted Lists題目:擁有兩個順序的列表,將兩個列表合併成一個順序的列表解法: code/** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */func mergeTwoLists(list1 *ListNode, list2 *ListNode) *ListNode { if list1 == nil { return list2 } if list2 == nil { return list1 } result := new(ListNode) if list1.Val &amp;gt;= list2.Val { result.Val = list2.Val result.Next = mergeTwoLists(list1, list2.Next) } else { result.Val = list1.Val result.Next = mergeTwoLists(list1.Next, list2) } return result}Best Time to Buy and Sell Stock題目:有一組陣列,key為天數,value為金額,你可以選擇一天買入,在另一天賣出(賣出沒辦法在買入之前),求最多賺多少金額?解法:先設定一個最小值(minNum)為陣列中可能出現的最大數和一個最大值(max)為0,跑陣列迴圈,如果值比minNum小,minNum=當前的值,如果當前值-minNum比max大,max為當前值-minNum,最後回傳max codefunc maxProfit(prices []int) int { var max int minNum := 10000 for _, value := range prices { if minNum &amp;gt; value { minNum = value } if value - minNum &amp;gt; max { max = value - minNum } } return max}" }, { "title": "leetCode Day1", "url": "/posts/leetCode-Day1/", "categories": "leetCode", "tags": "Tang", "date": "2022-10-31 00:00:00 +0800", "snippet": "Two Sum題目:給一組數字陣列和一個數字target,找出陣列中兩數相加等於target的位置解法:建立一個hash表, 跑陣列將陣列的key和value互換存入hash表, 如果target - value有在hash表存在,代表找到結果為key和hash表中target - value的值 codefunc twoSum(nums []int, target int) []int { tmp := make(map[int]int) for key, value := range nums { index, ok := tmp[target - value] if ok { return []int{key, index} } tmp[value] = key } return nil}Valid Parentheses題目:給一個字串只有(){}[]六個字元, 判斷這個字串是否合法? 1. 左括號一定有相應了右括號 2. 左右的括號必須是順序的 3.每一個右括號都要有一個相應的左括號解法:先判斷字串大小如果為奇數,返回false,跑迴圈,如果為左括號,將對應的右括號存入tmp中,如果為右括號,將tmp中最後存入的值拿出,判斷是否為相同的右括號,如果不同,返回false,如果相同,把tmp最後的值丟出,最後判斷tmp是否為空,如果為空,返回true,如果不為空,回傳false codefunc isValid(s string) bool { if len(s) % 2 == 1 { return false } tmp := []rune{} match := map[rune]rune { &#39;(&#39;: &#39;)&#39;, &#39;[&#39;: &#39;]&#39;, &#39;{&#39;: &#39;}&#39;, } for _, value := range s { closed, ok := match[value]; if ok { tmp = append(tmp, closed) continue } l := len(tmp) - 1 if l &amp;lt; 0 || value != tmp[l] { return false } tmp = tmp[:l] } return len(tmp) == 0}" }, { "title": "codeWars Day9", "url": "/posts/codeWars-Day9/", "categories": "codeWars", "tags": "Tang", "date": "2022-10-29 00:00:00 +0800", "snippet": "CamelCase Method題目:字串由空白作間隔,把字串第一個字遍大寫,並連起來解法:字串切割,第一個字轉大寫 codepackage kataimport &quot;strings&quot;func CamelCase(s string) string { var result string for _, value := range strings.Split(s, &quot; &quot;) { for key1 := range value { value1 := value[key1:key1 + 1] if key1 == 0 { value1 = strings.ToUpper(value[key1:key1 + 1]) } result += value1 } } return result}" }, { "title": "codeWars Day8", "url": "/posts/codeWars-Day8/", "categories": "codeWars", "tags": "Tang", "date": "2022-10-28 00:00:00 +0800", "snippet": "Tortoise racing題目:A會先跑G的距離,A的時速v1,B的時速v2,如果v1&amp;gt;v2, 表示追不到,回傳-1, 求B會在幾個小時幾分鐘幾分追到A解法:先算出A,B的速度差diff,在算差距/diff為小時,差距 * 60/diff % 60為分鐘,差距 * 3600/diff % 60為秒 codepackage katafunc Race(v1, v2, g int) [3]int { if (v1 &amp;gt; v2) { return [3]int{-1, -1, -1} } diff := v2 - v1 return [3]int{ g / diff, g * 60 / diff % 60 , g * 3600 / diff % 60 , }}" }, { "title": "codeWars Day7", "url": "/posts/codeWars-Day7/", "categories": "codeWars", "tags": "Tang", "date": "2022-10-27 00:00:00 +0800", "snippet": "How Much?題目:我有n至m元, 買了9輛c元的車,剩下1元, 買了7艘b元的船,剩下2元, 求所有可能的組合解法:迴圈跑n~m的金額, 找出同時符合汽車和船的金額 codepackage kataimport &quot;fmt&quot;func HowMuch(m int, n int) [][3]string { var result [][3]string if m &amp;gt; n { m, n = n, m } for i := m; i &amp;lt;= n; i++ { if i % 9 == 1 &amp;amp;&amp;amp; i % 7 == 2 { result = append(result, [3]string{ fmt.Sprintf(&quot;M: %d&quot;, i), fmt.Sprintf(&quot;B: %d&quot;, i / 7), fmt.Sprintf(&quot;C: %d&quot;, i / 9)}) } } return result}Persistent Bugger.題目:一個正整數num,將他每位數字相乘,值到算出的數字變成個位數,求計算了幾次解法:先判斷num是否大於10,如果大於10,去計算每位數字相乘 codepackage kataimport &quot;strconv&quot;func Persistence(n int) int { var count int for n &amp;gt; 9 { n, count = Multiply(n, count) } return count}func Multiply(n int, c int) (int, int) { sum := 1 s := strconv.Itoa(n) for i := range s { num, _ := strconv.Atoi(s[i:i+1]) sum *= num } c++ return sum, c}" }, { "title": "codeWars Day6", "url": "/posts/codeWars-Day6/", "categories": "codeWars", "tags": "Tang", "date": "2022-10-26 00:00:00 +0800", "snippet": "Highest Scoring Word題目:有一個字串,每個文字由空白做分別,計算出文字的最大分數,如果分數相同的話,找出比較早出現的那個,分數計算:a = 1, b = 2, c = 3解法:將字串切割,並將每個字母用int - 96換成分數,就能找出最早最大出現的字母 codepackage kataimport &quot;strings&quot;func High(s string) string { var maxSocres int var socres int var result string for _, value := range strings.Split(s, &quot; &quot;) { socres = 0 for _, value1 := range value { socres += int(value1) - 96 } if socres &amp;gt; maxSocres { maxSocres = socres result = value } } return result}Simple Fun #79: Delete a Digit題目:給一個數字,找出刪除一個位數的最大值解法:千位數和百位數做比較,如果百位數大於千位數,就刪除千位數,以此類推,如果到個位數都還沒刪除,就刪除個位數 codepackage kataimport &quot;strconv&quot;func DeleteDigit(n int) int { var result int s := strconv.Itoa(n) for i := range s { if i == len(s) - 1 || s[i] &amp;lt; s[i + 1] { result, _ = strconv.Atoi(s[:i] + s[i+1:]) break } } return result}" }, { "title": "codeWars Day5", "url": "/posts/codeWars-Day5/", "categories": "codeWars", "tags": "Tang", "date": "2022-10-25 00:00:00 +0800", "snippet": "Statistics for an Athletic Association題目:有多個時間用逗點區分,需要找出時間的範圍,平均,中位數解法:先把字串做切割,再把每個時間換算成秒數,存在另一個陣列arr,計算範圍,平均,中位數 codepackage kataimport &quot;strings&quot;import &quot;fmt&quot;import &quot;sort&quot;import &quot;strconv&quot;func Stati(strg string) string { var sum, total int var arr []int if strg == &quot;&quot; { return &quot;&quot; } for _, value := range strings.Split(strg, &quot;, &quot;) { sum = 0 for _, value1 := range strings.Split(value, &quot;|&quot;) { time, _ := strconv.Atoi(value1) sum = 60 * sum + time } arr = append(arr, sum) total += sum } sort.Ints(arr) rangeValue := arr[len(arr)-1] - arr[0] averageValue := total / len(arr) medianValue := 0 if len(arr) % 2 == 1 { medianValue = arr[len(arr) / 2] } else { medianValue = (arr[len(arr) / 2] + arr[len(arr) / 2 - 1]) / 2 } return fmt.Sprintf(&quot;Range: %02d|%02d|%02d Average: %02d|%02d|%02d Median: %02d|%02d|%02d&quot;, rangeValue / 3600, rangeValue % 3600 / 60, rangeValue % 60, averageValue / 3600, averageValue % 3600 / 60, averageValue % 60, medianValue / 3600, medianValue % 3600 / 60, medianValue % 60, )}Highest Rank Number in an Array題目:有一組數字陣列,找出出現頻率最高的數字,如果出現頻率有多個相同,找出數字最大的解法:遍歷陣列,找出頻率最高的數字寫入另一個陣列arr,排序arr,返回arr的最後一個數字 codepackage kataimport &quot;sort&quot;func HighestRank(nums []int) int { var arr1 []int arr := map[int]int{} maxCount := 0 for _, value := range nums { arr[value]++ if arr[value] &amp;gt; maxCount { maxCount = arr[value] arr1 = []int{value} } else if arr[value] == maxCount { arr1 = append(arr1, value) } } sort.Ints(arr1) return arr1[len(arr1) - 1]}" }, { "title": "codeWars Day4", "url": "/posts/codeWars-Day4/", "categories": "codeWars", "tags": "Tang", "date": "2022-10-24 00:00:00 +0800", "snippet": "Find the odd int題目:給你一個整數陣列,找出出現基數次的數字解法:建一個空陣列arr,跑原陣列,把值塞入arr陣列,值+1,跑arr判斷值為基數,返回值Sums of Parts題目:給你一個數字陣列,算出陣列總和,寫入另一個陣列,拿掉第一個值,再算出總和,寫入另一個陣列,直到陣列為空,輸出另一個陣列解法:先算出陣列總和,遍歷陣列總和=總和-值,並把總和寫入另一個陣列" }, { "title": "codeWars Day3", "url": "/posts/codeWars-Day3/", "categories": "codeWars", "tags": "Tang", "date": "2022-10-22 00:00:00 +0800", "snippet": "Two fighters, one winner.題目:有兩個決鬥者物件,都擁有名稱,血量,每下攻擊力這三個屬性,現在兩個決鬥者互毆判斷誰是獲勝者解法:先判斷誰先攻,然後跑一個迴圈,誰的血量先低於0,誰就輸了Shortest Word題目:給你一串詞,返回其中最短的字串, 字串不會為空,也不需要考慮其他數據形態解法:將詞用空白切割成每個字串,然後預設最小值為第一個字串的長度,然後一一比對每個詞的長度,直到陣列跑完" }, { "title": "codeWars Day2", "url": "/posts/codeWars-Day2/", "categories": "codeWars", "tags": "Tang", "date": "2022-10-21 00:00:00 +0800", "snippet": "Get the Middle Character題目:取得一個單字的中間值,如果單字長度為基數,回傳中間的一個字符,如果為偶數,回傳中間兩個字符解法:將字串切割成陣列,取得陣列長度,如果長度為基數,回傳無條件捨去長度/2的值,如果長度為偶數,回傳無條件捨去長度/2的值和前一個位置的值Don’t give me five!題目:給你開始和結束的數字,返回所有不包含5的數字數量解法:每個數字跑有沒有包含5" }, { "title": "codeWars Day1", "url": "/posts/codeWars-Day1/", "categories": "codeWars", "tags": "Tang", "date": "2022-10-20 00:00:00 +0800", "snippet": "Counting Duplicates題目:寫一個方法去計算一個英文字串不分大小寫並計算出現超過一次的字母總數解法:先定義一個空陣列為arr和結果res,將字串切割成另一組陣列,將陣列中每個字母轉成小/大寫,並寫入arr,把值加1,如果該字母在arr內為2的話,res就需要加1Highest and Lowest題目:有一個字串是由空格是間隔每個數字,需找出其中的最大值和最小值解法:先把字串以空格切割成陣列,將陣列的第一個值設為最大值和最小值,將最大值和最小值和陣列每個值去做比較,當陣列的值比最小值小,把最小值換成該值,當陣列的值比最大值大,把最大值換成該值,直到陣列跑完,就能取得該字串的最大值和最小值" }, { "title": "FactoryMethod", "url": "/posts/FactoryMethod/", "categories": "Design Pattern, FactoryMethod", "tags": "Tang", "date": "2022-06-22 00:00:00 +0800", "snippet": "FactoryMethod工廠方法模式( Factory Method )，定義一個用於建立物品的介面，讓子類決定實體化哪一個類別。工廠方法使一個類別的實例化延遲到其子類別。UMLExample Codeabstract class SocialNetworkPoster{ abstract public function getSocialNetwork(): SocialNetworkConnector; public function post($content): void { // Call the factory method to create a Product object... $network = $this-&amp;gt;getSocialNetwork(); // ...then use it as you will. $network-&amp;gt;logIn(); $network-&amp;gt;createPost($content); $network-&amp;gt;logout(); }}class FacebookPoster extends SocialNetworkPoster{ private $login, $password; public function __construct(string $login, string $password) { $this-&amp;gt;login = $login; $this-&amp;gt;password = $password; } public function getSocialNetwork(): SocialNetworkConnector { return new FacebookConnector($this-&amp;gt;login, $this-&amp;gt;password); }}class LinkedInPoster extends SocialNetworkPoster{ private $email, $password; public function __construct(string $email, string $password) { $this-&amp;gt;email = $email; $this-&amp;gt;password = $password; } public function getSocialNetwork(): SocialNetworkConnector { return new LinkedInConnector($this-&amp;gt;email, $this-&amp;gt;password); }}interface SocialNetworkConnector{ public function logIn(): void; public function logOut(): void; public function createPost($content): void;}class FacebookConnector implements SocialNetworkConnector{ private $login, $password; public function __construct(string $login, string $password) { $this-&amp;gt;login = $login; $this-&amp;gt;password = $password; } public function logIn(): void { echo &quot;Send HTTP API request to log in user $this-&amp;gt;login with &quot; . &quot;password $this-&amp;gt;password\\n&quot;; } public function logOut(): void { echo &quot;Send HTTP API request to log out user $this-&amp;gt;login\\n&quot;; } public function createPost($content): void { echo &quot;Send HTTP API requests to create a post in Facebook timeline.\\n&quot;; }}class LinkedInConnector implements SocialNetworkConnector{ private $email, $password; public function __construct(string $email, string $password) { $this-&amp;gt;email = $email; $this-&amp;gt;password = $password; } public function logIn(): void { echo &quot;Send HTTP API request to log in user $this-&amp;gt;email with &quot; . &quot;password $this-&amp;gt;password\\n&quot;; } public function logOut(): void { echo &quot;Send HTTP API request to log out user $this-&amp;gt;email\\n&quot;; } public function createPost($content): void { echo &quot;Send HTTP API requests to create a post in LinkedIn timeline.\\n&quot;; }}function clientCode(SocialNetworkPoster $creator){ // ... $creator-&amp;gt;post(&quot;Hello world!&quot;); $creator-&amp;gt;post(&quot;I had a large hamburger this morning!&quot;); // ...}echo &quot;Testing ConcreteCreator1:\\n&quot;;clientCode(new FacebookPoster(&quot;john_smith&quot;, &quot;******&quot;));echo &quot;\\n\\n&quot;;echo &quot;Testing ConcreteCreator2:\\n&quot;;clientCode(new LinkedInPoster(&quot;john_smith@example.com&quot;, &quot;******&quot;));出處:https://refactoring.guru/" }, { "title": "Builder", "url": "/posts/Builder/", "categories": "Design Pattern, Builder", "tags": "Tang", "date": "2022-06-22 00:00:00 +0800", "snippet": "Builder把一個複雜物件的建構與樣貌分離，如此相同的建構過程可以產生不同樣貌的物件UMLExample Codeinterface SQLQueryBuilder{ public function select(string $table, array $fields): SQLQueryBuilder; public function where(string $field, string $value, string $operator = &#39;=&#39;): SQLQueryBuilder; public function limit(int $start, int $offset): SQLQueryBuilder; // +100 other SQL syntax methods... public function getSQL(): string;}class MysqlQueryBuilder implements SQLQueryBuilder{ protected $query; protected function reset(): void { $this-&amp;gt;query = new \\stdClass(); } /** * Build a base SELECT query. */ public function select(string $table, array $fields): SQLQueryBuilder { $this-&amp;gt;reset(); $this-&amp;gt;query-&amp;gt;base = &quot;SELECT &quot; . implode(&quot;, &quot;, $fields) . &quot; FROM &quot; . $table; $this-&amp;gt;query-&amp;gt;type = &#39;select&#39;; return $this; } /** * Add a WHERE condition. */ public function where(string $field, string $value, string $operator = &#39;=&#39;): SQLQueryBuilder { if (!in_array($this-&amp;gt;query-&amp;gt;type, [&#39;select&#39;, &#39;update&#39;, &#39;delete&#39;])) { throw new \\Exception(&quot;WHERE can only be added to SELECT, UPDATE OR DELETE&quot;); } $this-&amp;gt;query-&amp;gt;where[] = &quot;$field $operator &#39;$value&#39;&quot;; return $this; } /** * Add a LIMIT constraint. */ public function limit(int $start, int $offset): SQLQueryBuilder { if (!in_array($this-&amp;gt;query-&amp;gt;type, [&#39;select&#39;])) { throw new \\Exception(&quot;LIMIT can only be added to SELECT&quot;); } $this-&amp;gt;query-&amp;gt;limit = &quot; LIMIT &quot; . $start . &quot;, &quot; . $offset; return $this; } /** * Get the final query string. */ public function getSQL(): string { $query = $this-&amp;gt;query; $sql = $query-&amp;gt;base; if (!empty($query-&amp;gt;where)) { $sql .= &quot; WHERE &quot; . implode(&#39; AND &#39;, $query-&amp;gt;where); } if (isset($query-&amp;gt;limit)) { $sql .= $query-&amp;gt;limit; } $sql .= &quot;;&quot;; return $sql; }}class PostgresQueryBuilder extends MysqlQueryBuilder{ /** * Among other things, PostgreSQL has slightly different LIMIT syntax. */ public function limit(int $start, int $offset): SQLQueryBuilder { parent::limit($start, $offset); $this-&amp;gt;query-&amp;gt;limit = &quot; LIMIT &quot; . $start . &quot; OFFSET &quot; . $offset; return $this; } // + tons of other overrides...}function clientCode(SQLQueryBuilder $queryBuilder){ // ... $query = $queryBuilder -&amp;gt;select(&quot;users&quot;, [&quot;name&quot;, &quot;email&quot;, &quot;password&quot;]) -&amp;gt;where(&quot;age&quot;, 18, &quot;&amp;gt;&quot;) -&amp;gt;where(&quot;age&quot;, 30, &quot;&amp;lt;&quot;) -&amp;gt;limit(10, 20) -&amp;gt;getSQL(); echo $query; // ...}echo &quot;Testing MySQL query builder:\\n&quot;;clientCode(new MysqlQueryBuilder());echo &quot;\\n\\n&quot;;echo &quot;Testing PostgresSQL query builder:\\n&quot;;clientCode(new PostgresQueryBuilder());出處:https://refactoring.guru/" }, { "title": "AbstractFactory", "url": "/posts/AbstractFactory/", "categories": "Design Pattern, AbstractFactory", "tags": "Tang", "date": "2022-06-22 00:00:00 +0800", "snippet": "AbstractFactory抽象工廠模式( Abstract Factory)，提供一個建立一系列相關或互相依賴物件的介面，而無需指定它們具體的類別。UMLExample Codeinterface TemplateFactory{ public function createTitleTemplate(): TitleTemplate; public function createPageTemplate(): PageTemplate; public function getRenderer(): TemplateRenderer;}class TwigTemplateFactory implements TemplateFactory{ public function createTitleTemplate(): TitleTemplate { return new TwigTitleTemplate(); } public function createPageTemplate(): PageTemplate { return new TwigPageTemplate($this-&amp;gt;createTitleTemplate()); } public function getRenderer(): TemplateRenderer { return new TwigRenderer(); }}class PHPTemplateFactory implements TemplateFactory{ public function createTitleTemplate(): TitleTemplate { return new PHPTemplateTitleTemplate(); } public function createPageTemplate(): PageTemplate { return new PHPTemplatePageTemplate($this-&amp;gt;createTitleTemplate()); } public function getRenderer(): TemplateRenderer { return new PHPTemplateRenderer(); }}interface TitleTemplate{ public function getTemplateString(): string;}class TwigTitleTemplate implements TitleTemplate{ public function getTemplateString(): string { return &quot;&amp;lt;h1&amp;gt;&amp;lt;/h1&amp;gt;&quot;; }}class PHPTemplateTitleTemplate implements TitleTemplate{ public function getTemplateString(): string { return &quot;&amp;lt;h1&amp;gt;&amp;lt;?= \\$title; ?&amp;gt;&amp;lt;/h1&amp;gt;&quot;; }}interface PageTemplate{ public function getTemplateString(): string;}abstract class BasePageTemplate implements PageTemplate{ protected $titleTemplate; public function __construct(TitleTemplate $titleTemplate) { $this-&amp;gt;titleTemplate = $titleTemplate; }}class TwigPageTemplate extends BasePageTemplate{ public function getTemplateString(): string { $renderedTitle = $this-&amp;gt;titleTemplate-&amp;gt;getTemplateString(); return &amp;lt;&amp;lt;&amp;lt;HTML &amp;lt;div class=&quot;page&quot;&amp;gt; $renderedTitle &amp;lt;article class=&quot;content&quot;&amp;gt;&amp;lt;!DOCTYPE html&amp;gt;&amp;lt;html lang=&quot;en&quot; mode=&quot;light&quot; &amp;gt; &amp;lt;!-- The Head--&amp;gt;&amp;lt;head&amp;gt; &amp;lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&amp;gt; &amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1, shrink-to-fit=no&quot;&amp;gt; &amp;lt;!-- i18n for `_javascript/utils/timeago.js` --&amp;gt; &amp;lt;meta name=&quot;day-prompt&quot; content=&quot;days ago&quot;&amp;gt; &amp;lt;meta name=&quot;hour-prompt&quot; content=&quot;hours ago&quot;&amp;gt; &amp;lt;meta name=&quot;minute-prompt&quot; content=&quot;minutes ago&quot;&amp;gt; &amp;lt;meta name=&quot;justnow-prompt&quot; content=&quot;just now&quot;&amp;gt; &amp;lt;!-- Begin Jekyll SEO tag v2.7.1 --&amp;gt;&amp;lt;meta name=&quot;generator&quot; content=&quot;Jekyll v4.2.1&quot; /&amp;gt;&amp;lt;meta property=&quot;og:title&quot; content=&quot;Docker ARG VS ENV&quot; /&amp;gt;&amp;lt;meta property=&quot;og:locale&quot; content=&quot;en&quot; /&amp;gt;&amp;lt;meta name=&quot;description&quot; content=&quot;ARG VS ENV&quot; /&amp;gt;&amp;lt;meta property=&quot;og:description&quot; content=&quot;ARG VS ENV&quot; /&amp;gt;&amp;lt;link rel=&quot;canonical&quot; href=&quot;https://onepouch.github.io/posts/Docker-ARG-ENV/&quot; /&amp;gt;&amp;lt;meta property=&quot;og:url&quot; content=&quot;https://onepouch.github.io/posts/Docker-ARG-ENV/&quot; /&amp;gt;&amp;lt;meta property=&quot;og:site_name&quot; content=&quot;OnePouch&quot; /&amp;gt;&amp;lt;meta property=&quot;og:type&quot; content=&quot;article&quot; /&amp;gt;&amp;lt;meta property=&quot;article:published_time&quot; content=&quot;2021-12-08T00:00:00+08:00&quot; /&amp;gt;&amp;lt;meta name=&quot;twitter:card&quot; content=&quot;summary&quot; /&amp;gt;&amp;lt;meta property=&quot;twitter:title&quot; content=&quot;Docker ARG VS ENV&quot; /&amp;gt;&amp;lt;meta name=&quot;twitter:site&quot; content=&quot;@OnePouch&quot; /&amp;gt;&amp;lt;meta name=&quot;google-site-verification&quot; content=&quot;google_meta_tag_verification&quot; /&amp;gt;&amp;lt;script type=&quot;application/ld+json&quot;&amp;gt;{&quot;description&quot;:&quot;ARG VS ENV&quot;,&quot;headline&quot;:&quot;Docker ARG VS ENV&quot;,&quot;dateModified&quot;:&quot;2021-12-08T00:00:00+08:00&quot;,&quot;url&quot;:&quot;https://onepouch.github.io/posts/Docker-ARG-ENV/&quot;,&quot;datePublished&quot;:&quot;2021-12-08T00:00:00+08:00&quot;,&quot;@type&quot;:&quot;BlogPosting&quot;,&quot;mainEntityOfPage&quot;:{&quot;@type&quot;:&quot;WebPage&quot;,&quot;@id&quot;:&quot;https://onepouch.github.io/posts/Docker-ARG-ENV/&quot;},&quot;@context&quot;:&quot;https://schema.org&quot;}&amp;lt;/script&amp;gt;&amp;lt;!-- End Jekyll SEO tag --&amp;gt; &amp;lt;title&amp;gt;Docker ARG VS ENV | OnePouch &amp;lt;/title&amp;gt; &amp;lt;!-- The Favicons for Web, Android, Microsoft, and iOS (iPhone and iPad) Apps Generated by: https://realfavicongenerator.net/--&amp;gt;&amp;lt;link rel=&quot;apple-touch-icon&quot; sizes=&quot;180x180&quot; href=&quot;/assets/img/favicons/apple-touch-icon.png&quot;&amp;gt;&amp;lt;link rel=&quot;icon&quot; type=&quot;image/png&quot; sizes=&quot;32x32&quot; href=&quot;/assets/img/favicons/favicon-32x32.png&quot;&amp;gt;&amp;lt;link rel=&quot;icon&quot; type=&quot;image/png&quot; sizes=&quot;16x16&quot; href=&quot;/assets/img/favicons/favicon-16x16.png&quot;&amp;gt;&amp;lt;link rel=&quot;manifest&quot; href=&quot;/assets/img/favicons/site.webmanifest&quot;&amp;gt;&amp;lt;link rel=&quot;shortcut icon&quot; href=&quot;/assets/img/favicons/favicon.ico&quot;&amp;gt;&amp;lt;meta name=&quot;apple-mobile-web-app-title&quot; content=&quot;OnePouch&quot;&amp;gt;&amp;lt;meta name=&quot;application-name&quot; content=&quot;OnePouch&quot;&amp;gt;&amp;lt;meta name=&quot;msapplication-TileColor&quot; content=&quot;#da532c&quot;&amp;gt;&amp;lt;meta name=&quot;msapplication-config&quot; content=&quot;/assets/img/favicons/browserconfig.xml&quot;&amp;gt;&amp;lt;meta name=&quot;theme-color&quot; content=&quot;#ffffff&quot;&amp;gt; &amp;lt;!-- Google Fonts --&amp;gt; &amp;lt;link rel=&quot;preconnect&quot; href=&quot;https://fonts.gstatic.com&quot; crossorigin=&quot;anonymous&quot;&amp;gt; &amp;lt;link rel=&quot;dns-prefetch&quot; href=&quot;https://fonts.gstatic.com&quot;&amp;gt; &amp;lt;!-- GA --&amp;gt; &amp;lt;link rel=&quot;preconnect&quot; href=&quot;https://www.google-analytics.com&quot; crossorigin=&quot;use-credentials&quot;&amp;gt; &amp;lt;link rel=&quot;dns-prefetch&quot; href=&quot;https://www.google-analytics.com&quot;&amp;gt; &amp;lt;link rel=&quot;preconnect&quot; href=&quot;https://www.googletagmanager.com&quot; crossorigin=&quot;anonymous&quot;&amp;gt; &amp;lt;link rel=&quot;dns-prefetch&quot; href=&quot;https://www.googletagmanager.com&quot;&amp;gt; &amp;lt;!-- jsDelivr CDN --&amp;gt; &amp;lt;link rel=&quot;preconnect&quot; href=&quot;https://cdn.jsdelivr.net&quot;&amp;gt; &amp;lt;link rel=&quot;dns-prefetch&quot; href=&quot;https://cdn.jsdelivr.net&quot;&amp;gt; &amp;lt;!-- Bootstrap --&amp;gt; &amp;lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css&quot;&amp;gt; &amp;lt;!-- Font Awesome --&amp;gt; &amp;lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css&quot;&amp;gt; &amp;lt;!-- CSS selector for site.--&amp;gt;&amp;lt;link rel=&quot;stylesheet&quot; href=&quot;/assets/css/style.css&quot;&amp;gt; &amp;lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css&quot;&amp;gt; &amp;lt;!-- Manific Popup --&amp;gt; &amp;lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css&quot;&amp;gt; &amp;lt;!-- JavaScript --&amp;gt; &amp;lt;script src=&quot;https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;&amp;lt;/head&amp;gt; &amp;lt;body data-spy=&quot;scroll&quot; data-target=&quot;#toc&quot;&amp;gt; &amp;lt;!-- The Side Bar--&amp;gt;&amp;lt;div id=&quot;sidebar&quot; class=&quot;d-flex flex-column align-items-end&quot; lang=&quot;en&quot;&amp;gt; &amp;lt;div class=&quot;profile-wrapper text-center&quot;&amp;gt; &amp;lt;div id=&quot;avatar&quot;&amp;gt; &amp;lt;a href=&quot;/&quot; alt=&quot;avatar&quot; class=&quot;mx-auto&quot;&amp;gt; &amp;lt;img src=&quot;https://i2.wp.com/one-pouch.com/wp-content/uploads/2019/05/cropped-蝴蝶結logo4t_工作區域-test-1.png?fit=32%2C32&amp;amp;ssl=1&quot; alt=&quot;avatar&quot; onerror=&quot;this.style.display=&#39;none&#39;&quot;&amp;gt; &amp;lt;/a&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;div class=&quot;site-title mt-3&quot;&amp;gt; &amp;lt;a href=&quot;/&quot;&amp;gt;OnePouch&amp;lt;/a&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;div class=&quot;site-subtitle font-italic&quot;&amp;gt;OnePouch 戴上一個幸運的期盼&amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt;&amp;lt;!-- .profile-wrapper --&amp;gt; &amp;lt;ul class=&quot;w-100&quot;&amp;gt; &amp;lt;!-- home --&amp;gt; &amp;lt;li class=&quot;nav-item&quot;&amp;gt; &amp;lt;a href=&quot;/&quot; class=&quot;nav-link&quot;&amp;gt; &amp;lt;i class=&quot;fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded&quot;&amp;gt;&amp;lt;/i&amp;gt; &amp;lt;span&amp;gt;HOME&amp;lt;/span&amp;gt; &amp;lt;/a&amp;gt; &amp;lt;/li&amp;gt; &amp;lt;!-- the real tabs --&amp;gt; &amp;lt;li class=&quot;nav-item&quot;&amp;gt; &amp;lt;a href=&quot;/categories/&quot; class=&quot;nav-link&quot;&amp;gt; &amp;lt;i class=&quot;fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded&quot;&amp;gt;&amp;lt;/i&amp;gt; &amp;lt;span&amp;gt;CATEGORIES&amp;lt;/span&amp;gt; &amp;lt;/a&amp;gt; &amp;lt;/li&amp;gt; &amp;lt;!-- .nav-item --&amp;gt; &amp;lt;li class=&quot;nav-item&quot;&amp;gt; &amp;lt;a href=&quot;/tags/&quot; class=&quot;nav-link&quot;&amp;gt; &amp;lt;i class=&quot;fa-fw fas fa-tag ml-xl-3 mr-xl-3 unloaded&quot;&amp;gt;&amp;lt;/i&amp;gt; &amp;lt;span&amp;gt;TAGS&amp;lt;/span&amp;gt; &amp;lt;/a&amp;gt; &amp;lt;/li&amp;gt; &amp;lt;!-- .nav-item --&amp;gt; &amp;lt;li class=&quot;nav-item&quot;&amp;gt; &amp;lt;a href=&quot;/archives/&quot; class=&quot;nav-link&quot;&amp;gt; &amp;lt;i class=&quot;fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded&quot;&amp;gt;&amp;lt;/i&amp;gt; &amp;lt;span&amp;gt;ARCHIVES&amp;lt;/span&amp;gt; &amp;lt;/a&amp;gt; &amp;lt;/li&amp;gt; &amp;lt;!-- .nav-item --&amp;gt; &amp;lt;li class=&quot;nav-item&quot;&amp;gt; &amp;lt;a href=&quot;/about/&quot; class=&quot;nav-link&quot;&amp;gt; &amp;lt;i class=&quot;fa-fw fas fa-info-circle ml-xl-3 mr-xl-3 unloaded&quot;&amp;gt;&amp;lt;/i&amp;gt; &amp;lt;span&amp;gt;ABOUT&amp;lt;/span&amp;gt; &amp;lt;/a&amp;gt; &amp;lt;/li&amp;gt; &amp;lt;!-- .nav-item --&amp;gt; &amp;lt;/ul&amp;gt; &amp;lt;!-- ul.nav.flex-column --&amp;gt; &amp;lt;div class=&quot;sidebar-bottom mt-auto d-flex flex-wrap justify-content-center align-items-center&quot;&amp;gt; &amp;lt;a href=&quot;https://github.com/OnePouch&quot; aria-label=&quot;github&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&amp;gt; &amp;lt;i class=&quot;fab fa-github&quot;&amp;gt;&amp;lt;/i&amp;gt; &amp;lt;/a&amp;gt; &amp;lt;a href=&quot;https://twitter.com/OnePouch&quot; aria-label=&quot;twitter&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&amp;gt; &amp;lt;i class=&quot;fab fa-twitter&quot;&amp;gt;&amp;lt;/i&amp;gt; &amp;lt;/a&amp;gt; &amp;lt;a href=&quot; javascript:location.href = &#39;mailto:&#39; + [&#39;lamon0624&#39;,&#39;gmail.com&#39;].join(&#39;@&#39;)&quot; aria-label=&quot;email&quot; &amp;gt; &amp;lt;i class=&quot;fas fa-envelope&quot;&amp;gt;&amp;lt;/i&amp;gt; &amp;lt;/a&amp;gt; &amp;lt;a href=&quot;/feed.xml&quot; aria-label=&quot;rss&quot; &amp;gt; &amp;lt;i class=&quot;fas fa-rss&quot;&amp;gt;&amp;lt;/i&amp;gt; &amp;lt;/a&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;!-- .sidebar-bottom --&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;!-- #sidebar --&amp;gt; &amp;lt;!-- The Top Bar--&amp;gt;&amp;lt;div id=&quot;topbar-wrapper&quot; class=&quot;row justify-content-center topbar-down&quot;&amp;gt; &amp;lt;div id=&quot;topbar&quot; class=&quot;col-11 d-flex h-100 align-items-center justify-content-between&quot;&amp;gt; &amp;lt;span id=&quot;breadcrumb&quot;&amp;gt; &amp;lt;span&amp;gt; &amp;lt;a href=&quot;/&quot;&amp;gt; Home &amp;lt;/a&amp;gt; &amp;lt;/span&amp;gt; &amp;lt;span&amp;gt;Docker ARG VS ENV&amp;lt;/span&amp;gt; &amp;lt;/span&amp;gt;&amp;lt;!-- endof #breadcrumb --&amp;gt; &amp;lt;i id=&quot;sidebar-trigger&quot; class=&quot;fas fa-bars fa-fw&quot;&amp;gt;&amp;lt;/i&amp;gt; &amp;lt;div id=&quot;topbar-title&quot;&amp;gt; Post &amp;lt;/div&amp;gt; &amp;lt;i id=&quot;search-trigger&quot; class=&quot;fas fa-search fa-fw&quot;&amp;gt;&amp;lt;/i&amp;gt; &amp;lt;span id=&quot;search-wrapper&quot; class=&quot;align-items-center&quot;&amp;gt; &amp;lt;i class=&quot;fas fa-search fa-fw&quot;&amp;gt;&amp;lt;/i&amp;gt; &amp;lt;input class=&quot;form-control&quot; id=&quot;search-input&quot; type=&quot;search&quot; aria-label=&quot;search&quot; autocomplete=&quot;off&quot; placeholder=&quot;Search...&quot;&amp;gt; &amp;lt;i class=&quot;fa fa-times-circle fa-fw&quot; id=&quot;search-cleaner&quot;&amp;gt;&amp;lt;/i&amp;gt; &amp;lt;/span&amp;gt; &amp;lt;span id=&quot;search-cancel&quot; &amp;gt;Cancel&amp;lt;/span&amp;gt; &amp;lt;/div&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;div id=&quot;main-wrapper&quot;&amp;gt; &amp;lt;div id=&quot;main&quot;&amp;gt; &amp;lt;!-- Refactor the HTML structure.--&amp;gt;&amp;lt;!-- In order to allow a wide table to scroll horizontally, we suround the markdown table with `&amp;lt;div class=&quot;table-wrapper&quot;&amp;gt;` and `&amp;lt;/div&amp;gt;`--&amp;gt;&amp;lt;!-- Fixed kramdown code highlight rendering: https://github.com/penibelst/jekyll-compress-html/issues/101 https://github.com/penibelst/jekyll-compress-html/issues/71#issuecomment-188144901--&amp;gt;&amp;lt;!-- Add attribute &#39;hide-bullet&#39; to the checkbox list --&amp;gt;&amp;lt;!-- images --&amp;gt; &amp;lt;!-- add CDN prefix if it exists --&amp;gt; &amp;lt;!-- lazy-load images &amp;lt;https://github.com/ApoorvSaxena/lozad.js#usage&amp;gt; --&amp;gt; &amp;lt;!-- add image placehoder to prevent layout reflow --&amp;gt; &amp;lt;!-- Add header for code snippets --&amp;gt;&amp;lt;!-- return --&amp;gt;&amp;lt;div class=&quot;row&quot;&amp;gt; &amp;lt;div id=&quot;post-wrapper&quot; class=&quot;col-12 col-lg-11 col-xl-8&quot;&amp;gt; &amp;lt;div class=&quot;post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4&quot;&amp;gt; &amp;lt;h1 data-toc-skip&amp;gt;Docker ARG VS ENV&amp;lt;/h1&amp;gt; &amp;lt;div class=&quot;post-meta text-muted d-flex flex-column&quot;&amp;gt; &amp;lt;!-- Published date and author --&amp;gt; &amp;lt;div&amp;gt; &amp;lt;span class=&quot;semi-bold&quot;&amp;gt; OnePouch &amp;lt;/span&amp;gt; &amp;lt;!-- Date format snippet See: /assets/js/_utils/timeage.js--&amp;gt; on&amp;lt;span class=&quot;timeago &quot; data-toggle=&quot;tooltip&quot; data-placement=&quot;bottom&quot; title=&quot;Wed, Dec 8, 2021, 12:00 AM +0800&quot; &amp;gt;Dec 8, 2021&amp;lt;i class=&quot;unloaded&quot;&amp;gt;2021-12-08T00:00:00+08:00&amp;lt;/i&amp;gt;&amp;lt;/span&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;div&amp;gt; &amp;lt;!-- lastmod --&amp;gt; &amp;lt;!-- read time --&amp;gt; &amp;lt;!-- Calculate the post&#39;s reading time, and display the word count in tooltip --&amp;gt;&amp;lt;!-- words per minute --&amp;gt;&amp;lt;!-- return element --&amp;gt;&amp;lt;span class=&quot;readtime&quot; data-toggle=&quot;tooltip&quot; data-placement=&quot;bottom&quot; title=&quot;84 words&quot;&amp;gt;1 min read&amp;lt;/span&amp;gt; &amp;lt;!-- page views --&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;!-- .post-meta --&amp;gt; &amp;lt;div class=&quot;post-content&quot;&amp;gt; &amp;lt;h2 id=&quot;arg-vs-env&quot;&amp;gt;ARG VS ENV&amp;lt;/h2&amp;gt;&amp;lt;p&amp;gt;建立image時使用變數用ARG,&amp;lt;/p&amp;gt;&amp;lt;p&amp;gt;運行container時使用變數用ENV(相同image跑不同的設定,ex:環境變數)&amp;lt;/p&amp;gt;&amp;lt;div class=&quot;language-dockerfile highlighter-rouge&quot;&amp;gt;&amp;lt;div class=&quot;code-header&quot;&amp;gt; &amp;lt;span text-data=&quot; Dockerfile&quot;&amp;gt;&amp;lt;i class=&quot;fa-fw fas fa-code small&quot;&amp;gt;&amp;lt;/i&amp;gt;&amp;lt;/span&amp;gt; &amp;lt;button aria-label=&quot;copy&quot; title-succeed=&quot;Copied!&quot;&amp;gt;&amp;lt;i class=&quot;far fa-clipboard&quot;&amp;gt;&amp;lt;/i&amp;gt;&amp;lt;/button&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;div class=&quot;highlight&quot;&amp;gt;&amp;lt;code&amp;gt;&amp;lt;table class=&quot;rouge-table&quot;&amp;gt;&amp;lt;tbody&amp;gt;&amp;lt;tr&amp;gt;&amp;lt;td class=&quot;rouge-gutter gl&quot;&amp;gt;&amp;lt;pre class=&quot;lineno&quot;&amp;gt;12&amp;lt;/pre&amp;gt;&amp;lt;/td&amp;gt;&amp;lt;td class=&quot;rouge-code&quot;&amp;gt;&amp;lt;pre&amp;gt;&amp;lt;span class=&quot;k&quot;&amp;gt;ARG&amp;lt;/span&amp;gt;&amp;lt;span class=&quot;s&quot;&amp;gt; var&amp;lt;/span&amp;gt;&amp;lt;span class=&quot;k&quot;&amp;gt;ENV&amp;lt;/span&amp;gt;&amp;lt;span class=&quot;s&quot;&amp;gt; var=${var}&amp;lt;/span&amp;gt;&amp;lt;/pre&amp;gt;&amp;lt;/td&amp;gt;&amp;lt;/tr&amp;gt;&amp;lt;/tbody&amp;gt;&amp;lt;/table&amp;gt;&amp;lt;/code&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;/div&amp;gt;&amp;lt;p&amp;gt;可以在建立image時有特定的var值(docker build –build-arg var=abc)或是運行container時有特別的運行值(docker run -e var=def)&amp;lt;/p&amp;gt;&amp;lt;p&amp;gt;&amp;lt;img data-proofer-ignore data-src=&quot;https://vsupalov.com/images/docker-env-vars/docker_environment_build_args.png&quot; alt=&quot;avatar&quot; /&amp;gt;&amp;lt;/p&amp;gt;&amp;lt;p&amp;gt;（圖片來源：vsupalov.com&amp;lt;/p&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;div class=&quot;post-tail-wrapper text-muted&quot;&amp;gt; &amp;lt;!-- categories --&amp;gt; &amp;lt;div class=&quot;post-meta mb-3&quot;&amp;gt; &amp;lt;i class=&quot;far fa-folder-open fa-fw mr-1&quot;&amp;gt;&amp;lt;/i&amp;gt; &amp;lt;a href=&#39;/categories/abc/&#39;&amp;gt;ABC&amp;lt;/a&amp;gt;, &amp;lt;a href=&#39;/categories/tools/&#39;&amp;gt;Tools&amp;lt;/a&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;!-- tags --&amp;gt; &amp;lt;div class=&quot;post-tags&quot;&amp;gt; &amp;lt;i class=&quot;fa fa-tags fa-fw mr-1&quot;&amp;gt;&amp;lt;/i&amp;gt; &amp;lt;a href=&quot;/tags/tang/&quot; class=&quot;post-tag no-text-decoration&quot; &amp;gt;Tang&amp;lt;/a&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;div class=&quot;post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2&quot;&amp;gt; &amp;lt;div class=&quot;license-wrapper&quot;&amp;gt; This post is licensed under &amp;lt;a href=&quot;https://creativecommons.org/licenses/by/4.0/&quot;&amp;gt; CC BY 4.0 &amp;lt;/a&amp;gt; by the author. &amp;lt;/div&amp;gt; &amp;lt;!-- Post sharing snippet--&amp;gt;&amp;lt;div class=&quot;share-wrapper&quot;&amp;gt; &amp;lt;span class=&quot;share-label text-muted mr-1&quot;&amp;gt;Share&amp;lt;/span&amp;gt; &amp;lt;span class=&quot;share-icons&quot;&amp;gt; &amp;lt;a href=&quot;https://twitter.com/intent/tweet?text=Docker ARG VS ENV - OnePouch&amp;amp;url=https://onepouch.github.io/posts/Docker-ARG-ENV/&quot; data-toggle=&quot;tooltip&quot; data-placement=&quot;top&quot; title=&quot;Twitter&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot; aria-label=&quot;Twitter&quot;&amp;gt; &amp;lt;i class=&quot;fa-fw fab fa-twitter&quot;&amp;gt;&amp;lt;/i&amp;gt; &amp;lt;/a&amp;gt; &amp;lt;a href=&quot;https://www.facebook.com/sharer/sharer.php?title=Docker ARG VS ENV - OnePouch&amp;amp;u=https://onepouch.github.io/posts/Docker-ARG-ENV/&quot; data-toggle=&quot;tooltip&quot; data-placement=&quot;top&quot; title=&quot;Facebook&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot; aria-label=&quot;Facebook&quot;&amp;gt; &amp;lt;i class=&quot;fa-fw fab fa-facebook-square&quot;&amp;gt;&amp;lt;/i&amp;gt; &amp;lt;/a&amp;gt; &amp;lt;a href=&quot;https://telegram.me/share?text=Docker ARG VS ENV - OnePouch&amp;amp;url=https://onepouch.github.io/posts/Docker-ARG-ENV/&quot; data-toggle=&quot;tooltip&quot; data-placement=&quot;top&quot; title=&quot;Telegram&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot; aria-label=&quot;Telegram&quot;&amp;gt; &amp;lt;i class=&quot;fa-fw fab fa-telegram&quot;&amp;gt;&amp;lt;/i&amp;gt; &amp;lt;/a&amp;gt; &amp;lt;i id=&quot;copy-link&quot; class=&quot;fa-fw fas fa-link small&quot; data-toggle=&quot;tooltip&quot; data-placement=&quot;top&quot; title=&quot;Copy link&quot; title-succeed=&quot;Link copied successfully!&quot;&amp;gt; &amp;lt;/i&amp;gt; &amp;lt;/span&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt;&amp;lt;!-- .post-tail-bottom --&amp;gt; &amp;lt;/div&amp;gt;&amp;lt;!-- div.post-tail --&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;!-- .post --&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;!-- #post-wrapper --&amp;gt; &amp;lt;!-- The Pannel on right side (Desktop views)--&amp;gt;&amp;lt;div id=&quot;panel-wrapper&quot; class=&quot;col-xl-3 pl-2 text-muted topbar-down&quot;&amp;gt; &amp;lt;div class=&quot;access&quot;&amp;gt; &amp;lt;div id=&quot;access-lastmod&quot; class=&quot;post&quot;&amp;gt; &amp;lt;span&amp;gt;Recent Update&amp;lt;/span&amp;gt; &amp;lt;ul class=&quot;post-content pl-0 pb-1 ml-1 mt-2&quot;&amp;gt; &amp;lt;li&amp;gt;&amp;lt;a href=&quot;/posts/leetCode-Day21/&quot;&amp;gt;leetCode Day21&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;&amp;lt;a href=&quot;/posts/leetCode-Day16/&quot;&amp;gt;leetCode Day16&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;&amp;lt;a href=&quot;/posts/leetCode-Day5/&quot;&amp;gt;leetCode Day5&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;&amp;lt;a href=&quot;/posts/codeWars-Day1/&quot;&amp;gt;codeWars Day1&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;&amp;lt;a href=&quot;/posts/codeWars-Day2/&quot;&amp;gt;codeWars Day2&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt; &amp;lt;/ul&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;!-- #access-lastmod --&amp;gt; &amp;lt;div id=&quot;access-tags&quot;&amp;gt; &amp;lt;span&amp;gt;Trending Tags&amp;lt;/span&amp;gt; &amp;lt;div class=&quot;d-flex flex-wrap mt-3 mb-1 mr-3&quot;&amp;gt; &amp;lt;a class=&quot;post-tag&quot; href=&quot;/tags/tang/&quot;&amp;gt;Tang&amp;lt;/a&amp;gt; &amp;lt;a class=&quot;post-tag&quot; href=&quot;/tags/docker/&quot;&amp;gt;Docker&amp;lt;/a&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;!-- .access --&amp;gt; &amp;lt;!-- BS-toc.js will be loaded at medium priority --&amp;gt; &amp;lt;script src=&quot;https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;div id=&quot;toc-wrapper&quot; class=&quot;pl-0 pr-4 mb-5&quot;&amp;gt; &amp;lt;span class=&quot;pl-3 pt-2 mb-2&quot;&amp;gt;Contents&amp;lt;/span&amp;gt; &amp;lt;nav id=&quot;toc&quot; data-toggle=&quot;toc&quot;&amp;gt;&amp;lt;/nav&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;!-- #panel-wrapper --&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;!-- .row --&amp;gt;&amp;lt;div class=&quot;row&quot;&amp;gt; &amp;lt;div class=&quot;col-12 col-lg-11 col-xl-8&quot;&amp;gt; &amp;lt;div id=&quot;post-extend-wrapper&quot; class=&quot;pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4&quot;&amp;gt; &amp;lt;!-- Recommend the other 3 posts according to the tags and categories of the current post, if the number is not enough, use the other latest posts to supplement.--&amp;gt;&amp;lt;!-- The total size of related posts --&amp;gt;&amp;lt;!-- An random integer that bigger than 0 --&amp;gt;&amp;lt;!-- Equals to TAG_SCORE / {max_categories_hierarchy} --&amp;gt; &amp;lt;!-- Fill with the other newlest posts --&amp;gt; &amp;lt;div id=&quot;related-posts&quot; class=&quot;mt-5 mb-2 mb-sm-4&quot;&amp;gt; &amp;lt;h3 class=&quot;pt-2 mt-1 mb-4 ml-1&quot; data-toc-skip&amp;gt;Further Reading&amp;lt;/h3&amp;gt; &amp;lt;div class=&quot;card-deck mb-4&quot;&amp;gt; &amp;lt;div class=&quot;card&quot;&amp;gt; &amp;lt;a href=&quot;/posts/Docker-Intro/&quot;&amp;gt; &amp;lt;div class=&quot;card-body&quot;&amp;gt; &amp;lt;!-- Date format snippet See: /assets/js/_utils/timeage.js--&amp;gt;&amp;lt;span class=&quot;timeago small&quot; &amp;gt;Nov 7, 2021&amp;lt;i class=&quot;unloaded&quot;&amp;gt;2021-11-07T00:00:00+08:00&amp;lt;/i&amp;gt;&amp;lt;/span&amp;gt; &amp;lt;h3 class=&quot;pt-0 mt-1 mb-3&quot; data-toc-skip&amp;gt;Docker 簡介 哇嗚 好棒&amp;lt;/h3&amp;gt; &amp;lt;div class=&quot;text-muted small&quot;&amp;gt; &amp;lt;p&amp;gt; 何謂容器,為何需要它 容器能和主機的操作系統共享資源,因而它的效率高出一個數量級。啟動和停止容器均只需一瞬間。相比在主機上直接運行程序,容器的性能耗損非常低,甚至是零耗損。 容器具有可移植性,徹底解決了不同環境的改變導致的問題。 容器是輕量的,意味著開發者可以同時運行數十個容器。更容易進行水平擴展。DockerfileFROM指定基礎鏡像 所謂定制... &amp;lt;/p&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/a&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;div class=&quot;card&quot;&amp;gt; &amp;lt;a href=&quot;/posts/leetCode-Day41/&quot;&amp;gt; &amp;lt;div class=&quot;card-body&quot;&amp;gt; &amp;lt;!-- Date format snippet See: /assets/js/_utils/timeage.js--&amp;gt;&amp;lt;span class=&quot;timeago small&quot; &amp;gt;Dec 13, 2022&amp;lt;i class=&quot;unloaded&quot;&amp;gt;2022-12-13T00:00:00+08:00&amp;lt;/i&amp;gt;&amp;lt;/span&amp;gt; &amp;lt;h3 class=&quot;pt-0 mt-1 mb-3&quot; data-toc-skip&amp;gt;leetCode Day41&amp;lt;/h3&amp;gt; &amp;lt;div class=&quot;text-muted small&quot;&amp;gt; &amp;lt;p&amp;gt; Find All Anagrams in a String題目:1有兩個字串,s和p,找出s字串中和p字串相似的子字串,並返回子字串開始的idx陣列解法:1先找出p字串中字母的出現次數為P,再將s陣列從頭掃過一次,P將字母--,如果該字母為0的話將,idx刪除,如果i大於等於p的長度,需把前面的字母加回來,如果P長度為0的話,表示為相似字串,將idx-p長度+1存入結果... &amp;lt;/p&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/a&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;div class=&quot;card&quot;&amp;gt; &amp;lt;a href=&quot;/posts/leetCode-Day42/&quot;&amp;gt; &amp;lt;div class=&quot;card-body&quot;&amp;gt; &amp;lt;!-- Date format snippet See: /assets/js/_utils/timeage.js--&amp;gt;&amp;lt;span class=&quot;timeago small&quot; &amp;gt;Dec 14, 2022&amp;lt;i class=&quot;unloaded&quot;&amp;gt;2022-12-14T00:00:00+08:00&amp;lt;/i&amp;gt;&amp;lt;/span&amp;gt; &amp;lt;h3 class=&quot;pt-0 mt-1 mb-3&quot; data-toc-skip&amp;gt;leetCode Day42&amp;lt;/h3&amp;gt; &amp;lt;div class=&quot;text-muted small&quot;&amp;gt; &amp;lt;p&amp;gt; Minimum Height Trees題目:1n為0~n-1的數字,edges為兩個數字的相連關西,此關西能組成一個樹,求哪個數字為根的話有最小的深度解法:1因圖型一定為樹,所以找出此樹最外層的點,最外層的點為只有一個相鄰的數字,將最外層的點剝離後,判斷剩下的數字是否只剩下一個或兩個,如果是的話,返回答案,如果不是的話,將繼續把最外層的數字剝離 codefu... &amp;lt;/p&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/a&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;!-- .card-deck --&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;!-- #related-posts --&amp;gt; &amp;lt;!-- Navigation buttons at the bottom of the post.--&amp;gt;&amp;lt;div class=&quot;post-navigation d-flex justify-content-between&quot;&amp;gt; &amp;lt;a href=&quot;/posts/Docker-Chapter5/&quot; class=&quot;btn btn-outline-primary&quot; prompt=&quot;Older&quot;&amp;gt; &amp;lt;p&amp;gt;Docker Chapter 5&amp;lt;/p&amp;gt; &amp;lt;/a&amp;gt; &amp;lt;a href=&quot;/posts/AbstractFactory/&quot; class=&quot;btn btn-outline-primary&quot; prompt=&quot;Newer&quot;&amp;gt; &amp;lt;p&amp;gt;AbstractFactory&amp;lt;/p&amp;gt; &amp;lt;/a&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;!-- #post-extend-wrapper --&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;!-- .col-* --&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;!-- .row --&amp;gt; &amp;lt;!-- The Footer--&amp;gt;&amp;lt;footer class=&quot;d-flex w-100 justify-content-center&quot;&amp;gt; &amp;lt;div class=&quot;d-flex justify-content-between align-items-center&quot;&amp;gt; &amp;lt;div class=&quot;footer-left&quot;&amp;gt; &amp;lt;p class=&quot;mb-0&quot;&amp;gt; © 2023 &amp;lt;a href=&quot;https://twitter.com/OnePouch&quot;&amp;gt;OnePouch&amp;lt;/a&amp;gt;. &amp;lt;span data-toggle=&quot;tooltip&quot; data-placement=&quot;top&quot; title=&quot;Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.&quot;&amp;gt;Some rights reserved.&amp;lt;/span&amp;gt; &amp;lt;/p&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;div class=&quot;footer-right&quot;&amp;gt; &amp;lt;p class=&quot;mb-0&quot;&amp;gt; Powered by &amp;lt;a href=&quot;https://jekyllrb.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&amp;gt;Jekyll&amp;lt;/a&amp;gt; with &amp;lt;a href=&quot;https://github.com/cotes2020/jekyll-theme-chirpy&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&amp;gt;Chirpy&amp;lt;/a&amp;gt; theme. &amp;lt;/p&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;!-- div.d-flex --&amp;gt;&amp;lt;/footer&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;!-- The Search results--&amp;gt;&amp;lt;div id=&quot;search-result-wrapper&quot; class=&quot;d-flex justify-content-center unloaded&quot;&amp;gt; &amp;lt;div class=&quot;col-12 col-sm-11 post-content&quot;&amp;gt; &amp;lt;div id=&quot;search-hints&quot;&amp;gt; &amp;lt;h4 class=&quot;text-muted mb-4&quot;&amp;gt;Trending Tags&amp;lt;/h4&amp;gt; &amp;lt;a class=&quot;post-tag&quot; href=&quot;/tags/tang/&quot;&amp;gt;Tang&amp;lt;/a&amp;gt; &amp;lt;a class=&quot;post-tag&quot; href=&quot;/tags/docker/&quot;&amp;gt;Docker&amp;lt;/a&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;div id=&quot;search-results&quot; class=&quot;d-flex flex-wrap justify-content-center text-muted mt-3&quot;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;!-- #main-wrapper --&amp;gt; &amp;lt;div id=&quot;mask&quot;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;a id=&quot;back-to-top&quot; href=&quot;#&quot; aria-label=&quot;back-to-top&quot; class=&quot;btn btn-lg btn-box-shadow&quot; role=&quot;button&quot;&amp;gt; &amp;lt;i class=&quot;fas fa-angle-up&quot;&amp;gt;&amp;lt;/i&amp;gt; &amp;lt;/a&amp;gt; &amp;lt;!-- Jekyll Simple Search loader See: &amp;lt;https://github.com/christian-fei/Simple-Jekyll-Search&amp;gt;--&amp;gt;&amp;lt;script src=&quot;https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.10.0/dest/simple-jekyll-search.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;&amp;lt;script&amp;gt;SimpleJekyllSearch({ searchInput: document.getElementById(&#39;search-input&#39;), resultsContainer: document.getElementById(&#39;search-results&#39;), json: &#39;/assets/js/data/search.json&#39;, searchResultTemplate: &#39;&amp;lt;div class=&quot;pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0&quot;&amp;gt; &amp;lt;a href=&quot;{url}&quot;&amp;gt;{title}&amp;lt;/a&amp;gt; &amp;lt;div class=&quot;post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1&quot;&amp;gt; {categories} {tags} &amp;lt;/div&amp;gt; &amp;lt;p&amp;gt;{snippet}&amp;lt;/p&amp;gt;&amp;lt;/div&amp;gt;&#39;, noResultsText: &#39;&amp;lt;p class=&quot;mt-5&quot;&amp;gt;Oops! No result founds.&amp;lt;/p&amp;gt;&#39;, templateMiddleware: function(prop, value, template) { if (prop === &#39;categories&#39;) { if (value === &#39;&#39;) { return `${value}`; } else { return `&amp;lt;div class=&quot;mr-sm-4&quot;&amp;gt;&amp;lt;i class=&quot;far fa-folder fa-fw&quot;&amp;gt;&amp;lt;/i&amp;gt;${value}&amp;lt;/div&amp;gt;`; } } if (prop === &#39;tags&#39;) { if (value === &#39;&#39;) { return `${value}`; } else { return `&amp;lt;div&amp;gt;&amp;lt;i class=&quot;fa fa-tag fa-fw&quot;&amp;gt;&amp;lt;/i&amp;gt;${value}&amp;lt;/div&amp;gt;`; } } }});&amp;lt;/script&amp;gt; &amp;lt;!-- JS selector for site.--&amp;gt;&amp;lt;!-- layout specified --&amp;gt; &amp;lt;!-- image lazy-loading &amp;amp; popup --&amp;gt; &amp;lt;script src=&quot;https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js,npm/clipboard@2/dist/clipboard.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;&amp;lt;script defer src=&quot;/assets/js/dist/post.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt;&amp;lt;!-- commons --&amp;gt;&amp;lt;script src=&quot;https://cdn.jsdelivr.net/combine/npm/popper.js@1.16.1,npm/bootstrap@4/dist/js/bootstrap.min.js&quot;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;!-- PWA --&amp;gt; &amp;lt;script defer src=&quot;/app.js&quot;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;!-- GA --&amp;gt; &amp;lt;!-- The GA snippet--&amp;gt;&amp;lt;!-- Global site tag (gtag.js) - Google Analytics --&amp;gt;&amp;lt;script defer src=&quot;https://www.googletagmanager.com/gtag/js?id=&quot;&amp;gt;&amp;lt;/script&amp;gt;&amp;lt;script&amp;gt; document.addEventListener(&quot;DOMContentLoaded&quot;, function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag(&#39;js&#39;, new Date()); gtag(&#39;config&#39;, &#39;&#39;); });&amp;lt;/script&amp;gt; &amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;&amp;lt;/article&amp;gt; &amp;lt;/div&amp;gt; HTML; }}class PHPTemplatePageTemplate extends BasePageTemplate{ public function getTemplateString(): string { $renderedTitle = $this-&amp;gt;titleTemplate-&amp;gt;getTemplateString(); return &amp;lt;&amp;lt;&amp;lt;HTML &amp;lt;div class=&quot;page&quot;&amp;gt; $renderedTitle &amp;lt;article class=&quot;content&quot;&amp;gt;&amp;lt;?= \\$content; ?&amp;gt;&amp;lt;/article&amp;gt; &amp;lt;/div&amp;gt; HTML; }}interface TemplateRenderer{ public function render(string $templateString, array $arguments = []): string;}class TwigRenderer implements TemplateRenderer{ public function render(string $templateString, array $arguments = []): string { return \\Twig::render($templateString, $arguments); }}class PHPTemplateRenderer implements TemplateRenderer{ public function render(string $templateString, array $arguments = []): string { extract($arguments); ob_start(); eval(&#39; ?&amp;gt;&#39; . $templateString . &#39;&amp;lt;?php &#39;); $result = ob_get_contents(); ob_end_clean(); return $result; }}class Page{ public $title; public $content; public function __construct($title, $content) { $this-&amp;gt;title = $title; $this-&amp;gt;content = $content; } // Here&#39;s how would you use the template further in real life. Note that the // page class does not depend on any concrete template classes. public function render(TemplateFactory $factory): string { $pageTemplate = $factory-&amp;gt;createPageTemplate(); $renderer = $factory-&amp;gt;getRenderer(); return $renderer-&amp;gt;render($pageTemplate-&amp;gt;getTemplateString(), [ &#39;title&#39; =&amp;gt; $this-&amp;gt;title, &#39;content&#39; =&amp;gt; $this-&amp;gt;content ]); }}$page = new Page(&#39;Sample page&#39;, &#39;This is the body.&#39;);echo &quot;Testing actual rendering with the PHPTemplate factory:\\n&quot;;echo $page-&amp;gt;render(new PHPTemplateFactory());出處:https://refactoring.guru/" }, { "title": "Docker ARG VS ENV", "url": "/posts/Docker-ARG-ENV/", "categories": "ABC, Tools", "tags": "Tang", "date": "2021-12-08 00:00:00 +0800", "snippet": "ARG VS ENV建立image時使用變數用ARG,運行container時使用變數用ENV(相同image跑不同的設定,ex:環境變數)ARG varENV var=${var}可以在建立image時有特定的var值(docker build –build-arg var=abc)或是運行container時有特別的運行值(docker run -e var=def)（圖片來源：vsupalov.com" }, { "title": "Docker Chapter 5", "url": "/posts/Docker-Chapter5/", "categories": "Docker, Tools", "tags": "Docker", "date": "2021-11-10 00:00:00 +0800", "snippet": "123213123!!!" }, { "title": "Docker 簡介 哇嗚 好棒", "url": "/posts/Docker-Intro/", "categories": "ABC, Tools", "tags": "Tang", "date": "2021-11-07 00:00:00 +0800", "snippet": "何謂容器,為何需要它 容器能和主機的操作系統共享資源,因而它的效率高出一個數量級。啟動和停止容器均只需一瞬間。相比在主機上直接運行程序,容器的性能耗損非常低,甚至是零耗損。 容器具有可移植性,徹底解決了不同環境的改變導致的問題。 容器是輕量的,意味著開發者可以同時運行數十個容器。更容易進行水平擴展。DockerfileFROM指定基礎鏡像 所謂定制鏡像,那一定是以一個鏡像為基礎,在其上進行定制。 FROM就是指定鏡像,因此一個Dockerfile中FROM是必備的指令,並且必須為第一條指令。 Docker Hub上面有許多官方鏡像 服務類鏡像,如nginx、redis、mongo、mysql、httpd…等 各種語言應用鏡像,如node、python、ruby、golang…等 操作系統鏡像,如ubuntu、debian、centos、alpine…等 RUN執行命令 RUN指令是用來執行命令的。 RUN指令在定制鏡像時是最常用的指令之一。其格式有兩種： shell格式：RUN ,就像直接在命令行中輸入的命令一樣 RUN echo &#39;&amp;lt;h1&amp;gt;Hello, Docker!&amp;lt;/h1&amp;gt;&#39; &amp;gt; /usr/share/nginx/html/index.html exec格式：RUN [“可執行文件”, “參數1”, “參數2”],這更像是函數調用中的格式Dockerfile中每一個指令都會建立一層,RUN也不例外。每一個RUN的行為,都會建立新的一層。由於不必要的層會使鏡像變得臃腫(AUFS最多只能有127層),你會發現許多Dockerfile都把多個命令放在同一個RUN指令中,以減少層的數量。 " } ]
