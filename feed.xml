<feed xmlns="http://www.w3.org/2005/Atom"> <id>https://onepouch.github.io/</id><title>OnePouch</title><subtitle>A minimal, portfolio, sidebar, bootstrap Jekyll theme with responsive web design and focuses on text presentation.</subtitle> <updated>2023-03-29T23:08:36+08:00</updated> <author> <name>OnePouch</name> <uri>https://onepouch.github.io/</uri> </author><link rel="self" type="application/atom+xml" href="https://onepouch.github.io/feed.xml"/><link rel="alternate" type="text/html" hreflang="en" href="https://onepouch.github.io/"/> <generator uri="https://jekyllrb.com/" version="4.2.1">Jekyll</generator> <rights> © 2023 OnePouch </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry><title>leetCode Day50</title><link href="https://onepouch.github.io/posts/leetCode-Day50/" rel="alternate" type="text/html" title="leetCode Day50" /><published>2022-12-26T00:00:00+08:00</published> <updated>2022-12-26T00:00:00+08:00</updated> <id>https://onepouch.github.io/posts/leetCode-Day50/</id> <content src="https://onepouch.github.io/posts/leetCode-Day50/" /> <author> <name>OnePouch</name> </author> <category term="leetCode" /> <summary> Find the Duplicate Number 題目: 有一個數字陣列,有n + 1的數字,數字的值為1~n,求陣列中重複的數字 解法: 建立一個陣列,用數字為key,值為bool,數字出現過設定為true,如果數字為true,代表重複出現 code func findDuplicate(nums []int) int { exist := make([]bool, len(nums)) for _, value := range nums { if exist[value] { return value } exist[value] = true } return 0 } </summary> </entry> <entry><title>leetCode Day49</title><link href="https://onepouch.github.io/posts/leetCode-Day49/" rel="alternate" type="text/html" title="leetCode Day49" /><published>2022-12-24T00:00:00+08:00</published> <updated>2022-12-24T00:00:00+08:00</updated> <id>https://onepouch.github.io/posts/leetCode-Day49/</id> <content src="https://onepouch.github.io/posts/leetCode-Day49/" /> <author> <name>OnePouch</name> </author> <category term="leetCode" /> <summary> Remove Nth Node From End of List 題目: 有一個列表,刪除從後面數來第n個節點 解法: 因為我們要找出後面數來第n個,所以我們可以用初始點和出點後往後n個當作依據,同時往後,執到後面那個跑到最後一個,前面的就會是需要刪除節點的前一個節點,把前一個節點的下一個節點,設定為下兩個節點,就可以刪除該節點 code /** * Definition for singly-linked list. * type ListNode struct { * Val int * Next *ListNode * } */ func removeNthFromEnd(head *ListNode, n int) *ListNode { left := head right := head for i ... </summary> </entry> <entry><title>leetCode Day48</title><link href="https://onepouch.github.io/posts/leetCode-Day48/" rel="alternate" type="text/html" title="leetCode Day48" /><published>2022-12-23T00:00:00+08:00</published> <updated>2022-12-23T00:00:00+08:00</updated> <id>https://onepouch.github.io/posts/leetCode-Day48/</id> <content src="https://onepouch.github.io/posts/leetCode-Day48/" /> <author> <name>OnePouch</name> </author> <category term="leetCode" /> <summary> Pacific Atlantic Water Flow 題目: 有一個數字矩陣代表了水的高度,上方和左方為太平洋,右方和下方為大西洋,水會往低處流,求哪幾個節點同時流往太平洋和大西洋 解法: 如果使用每個節點往四周跑dfs的話,有很多點需要重複執行,導致timeout,所以定義兩個布林矩陣,為能到達太平洋或大西洋,從邊界開始往四周跑,最後看每個點是否通過太平洋和大西洋 code func pacificAtlantic(heights [][]int) [][]int { var result [][]int var p [][]bool var a [][]bool m := len(heights) n := len(heights[0]) for i := 0; i &amp;lt; m; i++ { ... </summary> </entry> <entry><title>leetCode Day47</title><link href="https://onepouch.github.io/posts/leetCode-Day47/" rel="alternate" type="text/html" title="leetCode Day47" /><published>2022-12-20T00:00:00+08:00</published> <updated>2022-12-20T00:00:00+08:00</updated> <id>https://onepouch.github.io/posts/leetCode-Day47/</id> <content src="https://onepouch.github.io/posts/leetCode-Day47/" /> <author> <name>OnePouch</name> </author> <category term="leetCode" /> <summary> Maximum Product Subarray 題目: 有一個數字陣列,求子陣列中,乘積最大 解法: 使用動態規劃,定義乘積最大和最小,如果值為正,乘積最大為max(dpMax[i-1]*nums[i],nums[i]),乘積最小為min(dpMin[i-1]*nums[i],nums[i]),如果值為負數,乘積最大為max(dpMin[i-1]*nums[i],nums[i]),乘積最小為min(dpMax[i-1]*nums[i],nums[i]) code func maxProduct(nums []int) int { dpMax := make([]int, len(nums)) dpMin := make([]int, len(nums)) dpMax[0] = nums[0] dpMin[0] = nums[0] ... </summary> </entry> <entry><title>leetCode Day46</title><link href="https://onepouch.github.io/posts/leetCode-Day46/" rel="alternate" type="text/html" title="leetCode Day46" /><published>2022-12-19T00:00:00+08:00</published> <updated>2022-12-19T00:00:00+08:00</updated> <id>https://onepouch.github.io/posts/leetCode-Day46/</id> <content src="https://onepouch.github.io/posts/leetCode-Day46/" /> <author> <name>OnePouch</name> </author> <category term="leetCode" /> <summary> Next Permutation 題目: 有一個數字陣列,找出下一個比較大的最小數,如果都沒有的話,返回最小數 解法: 從後往前看,如果為順序遞增的話,返回排序陣列,如果中間有一數較小,找出該數位置,再由後往前找出最小大於該數的位置,由於後往前一定為遞增,所以從後往前遇到的第一個比較大的數一定是最小的,兩個位置交換,在將i後面的數字排序 code func nextPermutation(nums []int) { i := len(nums) - 1 for i &amp;gt;= 1 &amp;amp;&amp;amp; nums[i] &amp;lt;= nums[i - 1] { i-- } if i == 0 { sort.Ints(nums) return } i-- j := l... </summary> </entry> </feed>
